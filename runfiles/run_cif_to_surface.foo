! Copyright (C) Dylan Jayatilaka, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! modified from run_metal_surface.foo by Dylan Jayatilaka and Peter
! Spackman 2014

program run_CIF_TO_SURFACE

    implicit none

    command_line :: COMMAND_LINE
    output :: TEXTFILE*
    s, option, value, cif,cxs :: STR
    directory :: STR
    property :: VEC{STR}(6)
    res :: REAL
    a, N :: INT
    found :: BIN
    m :: MOLECULE*

    ! Moment generating variables
    qc, qs :: VEC{REAL}*
    property_coefficients, coefficients :: VEC{CPX}*
    l_max :: INT
    radius :: REAL
    in, out :: VEC{INT}*
    invariants :: VEC{REAL}*
    surface :: MAT{REAL}*
    d_e, d_i, d_norm, d_norm_e, d_norm_i :: VEC{REAL}*
    spherical :: SPHERICAL*
    ! Macro to create Tonto system object
    ! Initialise MPI parallel stuff too.
    TONTO_CREATE

    ! Initialise standard I/O files.
    ! Always have this.
    std_time.start_timing

    stdin.create_stdin; !stdin.open
    stdout.create_stdout ! ; stdout.open
    stderr.create_stderr; stderr.open

    ! Get the command line
    command_line.process_options
    DIE_IF(command_line.has_arguments,"illegal arguments; use options only")

    ! Default options
    cif = "input.cif"
    cxs = "output.cxs"
    res = 0.5
    l_max = 10
    ! Analyze command line options
    do a = 1,command_line.n_options

        ! Get options
        option = command_line.option(a)
        value  = command_line.option_value(a)

            ! Analyze options
        select case (option)
            case("cif");  cif = value
            case("cxs");  cxs = value
            case("res");  res = value.to_real
            case("lmax");  l_max = value.to_int
            case default; DIE("unknown option: "//trim(option))
        end

    end

    property(1) = "d_e"
    property(2) = "d_i"
    property(3) = "d_norm_e"
    property(4) = "d_norm_i"
    property(5) = "d_norm"
    property(6) = "shape"
    ! Clean command line
    command_line.destroy_ptr_part

    ! Initialize molecule
    m.BASE:create
    GAUSSIAN_DATA:set_indices(GAUSSIAN_DATA_L_MAX)

    ! Tonto banner
    !MOLECULE.MAIN:put_banner

    ! Script banner
    stdout.flush
    stdout.text("====================================")
    stdout.text("Standalone Hirshfeld surface program")
    stdout.text("====================================")
    stdout.flush
    stdout.text(". This program generates a Hirshfeld surface and its")
    stdout.text("  corresponding fingerprint directly from a cif file")
    stdout.flush
    stdout.text(". It only works for Z'==1 now ... ")
    stdout.flush
    stdout.show("CIF file     =",cif)
    stdout.show("CXS file     =",cxs)
    stdout.show("l_max        =", l_max)

    ! Set basis_set library folder
    directory = "./basis_sets"
    m.basis.set_library_directory(directory)
    m.slaterbasis.set_library_directory(directory)
    m.coppensbasis.set_library_directory(directory)

    ! Set Thakkar basis set
    m.BASE:set_slaterbasis_name("Thakkar")
    ! Create CIF object
    m.cif.create
    m.cif.set_file_name(cif)

    ! Set CIF to use bond-length normalization
    m.cif.CH_bond_length = 1.083
    m.cif.NH_bond_length = 1.009
    m.cif.OH_bond_length = 0.983
    m.cif.BH_bond_length = 1.180
    m.cif.CH_bond_length.convert_from("angstrom")
    m.cif.NH_bond_length.convert_from("angstrom")
    m.cif.OH_bond_length.convert_from("angstrom")
    m.cif.BH_bond_length.convert_from("angstrom")

    ! Find CIF data block
    m.CE:find_CIF_crystal_data_block(m.cif,found)
    DIE_IF(NOT found,"no data block found in the CIF file!")

    ! Read/process CIF
    m.XTAL:read_CIF_atoms(m.cif)
    m.XTAL:read_CIF_crystal(m.cif)

    ! Initialize cluster for HS
    m.cluster.create(m.crystal)
    m.cluster.set_generation_method("for_hirshfeld_surface")
    m.cluster.atom_density_cutoff = 1.0e-8
    m.cluster.defragment = FALSE
    m.cluster.make_info
    !m.cluster.put
    m.XTAL:create_cluster

    ! Initialize interpolator for HS
    m.interpolator.create
    m.interpolator.set_interpolation_method("linear")
    m.interpolator.set_domain_mapping("sqrt")
    m.interpolator.set_table_eps(TOL(10))
    m.interpolator.set_table_spacing(TOL(1))
    m.BASE:destroy_interpolators

    ! Create CX_isosurface
    m.isosurface.create(m.atom)
    m.isosurface.plot_grid.set_defaults(m.saved.atom)
    m.isosurface.plot_grid.n_x = 2**ISOSURFACE_MINIMUM_SCAN_LEVEL + 1
    m.isosurface.plot_grid.set_points_widths_origin

    ! Initialize CX_isosurface
    m.isosurface.property = "stockholder_weight"
    m.isosurface.triangulation_method = "recursive_marching_cube"
    m.isosurface.iso_value = 0.5
    m.isosurface.surface_property = "none"
    m.isosurface.minimum_scan_division = 1
    m.isosurface.voxel_proximity_factor = 5
    m.isosurface.CX_output_distance_properties = TRUE
    m.isosurface.CX_output_shape_properties = FALSE

    ! Initialize CX_isosurface.plot_grid
    m.isosurface.plot_grid.reset_defaults ! don't reset bounding box or axes
    m.isosurface.plot_grid.use_bcube_with_shape_axes
    m.isosurface.plot_grid.set_cube_scale_factor(ONE)

    ! Desired separation is essentially the resolution of the calculated surface
    m.isosurface.plot_grid.desired_separation = res



    ! Make isosurface
    m.PLOT:isosurface_plot

    ! Output cxs surface file ... in angstrom
    m.CX_uses_angstrom = TRUE
    output.create(trim(cxs))
    output.open(for="write")
    m.CE:put_CX_data(output,m.cif)

    out.create(m.saved.cluster.nonfragment_atom_indices.dim)
    in.create(m.saved.cluster.fragment_atom_indices.dim)
    in = m.saved.cluster.fragment_atom_indices
    out = m.saved.cluster.nonfragment_atom_indices

    ! do calculation 
    output.set_using_fields(FALSE)
    output.set_real_style("e")
    
    ! spherical harmonic decomposition
    spherical.create
    surface.create(m.isosurface.n_pt, 3)
    surface = transpose(m.isosurface.point)

    print *, "Decomposing surface function into sum of spherical harmonics"
    stdout.flush
    d_i.create(m.isosurface.n_pt)
    d_e.create(m.isosurface.n_pt)
    d_norm_i.create(m.isosurface.n_pt)
    d_norm_e.create(m.isosurface.n_pt)
    d_norm.create(m.isosurface.n_pt)

    m.isosurface.make_fingerprint_distances(d_e,d_i,d_norm_e,d_norm_i,d_norm,in,out,m.isosurface.atom, angstrom = TRUE)

    print *, d_norm
    radius = spherical.get_surface_decomposition(coefficients, property_coefficients, l_max, 5810, surface, d_norm)


    ! reconstruct the surface
    !spherical.reconstruct_shape(coefficients, points, l_max)
!    print *,"begin vertices_recon", points.dim1
!    do N = 1, points.dim1
!        print *, points(N,:)
!   end
!    print *,"end vertices_recon"

    ! write the multipole moments
    do N=1,property.dim
        m.isosurface.make_surface_multipole_moments(qc, qs, in, out, l_max, property(N))
        a = qc.dim * 2
        s.from_int(a)
        s = "begin moments_" // trim(property(N)) // " " // trim(s)
        output.text(s)
        output.put(qc)
        output.put(qs)
        output.text("end moments_"// trim(property(N)))
    end

    ! put out the coefficients
    output.flush
    s.from_int((l_max+1)**2)
    output.text("begin coefficients "//trim(s))
    do N=1,(l_max+1)**2
        output.put(coefficients(N))
        output.text(" ")
    end
    output.text("end coefficients")
    output.flush
    output.text("begin property_coefficients "//trim(s))
    do N=1,(l_max+1)**2
        output.put(property_coefficients(N))
        output.text(" ")
    end
    output.text("end property_coefficients")
    output.flush

    spherical.make_invariants(coefficients, l_max, invariants)

    s.from_int(invariants.dim)
    output.text("begin invariants "//trim(s))
    do N = 1, invariants.dim
        output.put(invariants(N))
        output.text(" ")
    end
    output.text("end invariants")
    output.flush

    out.destroy
    in.destroy
    output.destroy



    TONTO_REPORT
    ! Destroy for next cluster
    m.cluster.destroy

    m.MAIN:cleanup
    ! Clean-up files
    TEXTFILE:destroy(stdout)
    TEXTFILE:destroy(stderr)
    TEXTFILE:destroy(stdin)

    ! Memory report
    TONTO_REPORT

    ! Clean-up tonto system
    TONTO_DESTROY

end
