!-------------------------------------------------------------------------------
!
! T_TENSOR: produces the elements of cartesian interaction tensors aka 
! 'T tensors' used in electrodynamics
!
! Copyright (C) Peter Spackman, 2017
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!-------------------------------------------------------------------------------
module T_TENSOR
   implicit none

contains
   create(a, b)
   ! create the T tensors from two locations
      a, b :: VEC{REAL}(3), IN
      a_b :: VEC{REAL}(3)
      r :: REAL
      i, j, k, l :: INT
      a_b = b - a
      r = a_b.norm
      .scalar = t0(r)

      do i = 1, 3 
         .alpha(i) = t1(r, a_b(i))
      end do

      do i = 1, 3
      do j = 1, 3
         .alpha_beta(i,j) = t2(r, [a_b(i), a_b(j)], [i,j])
      end do
      end do

      do i = 1, 3
      do j = 1, 3
      do k = 1, 3
         .alpha_beta_gamma(i,j,k) = t2(r, [a_b(i), a_b(j), a_b(k)], [i,j,k])
      end do
      end do
      end do

      do i = 1, 3
      do j = 1, 3
      do k = 1, 3
      do l = 1, 3
         .alpha_beta_gamma_delta(i,j,k,l) = t2(r,[a_b(i),a_b(j),a_b(k),a_b(l)], [i,j,k,l])
      end do
      end do
      end do
      end do
      stdout.text("A-B")
      stdout.put(a_b)
      stdout.show("|A-B|", r)

      stdout.put(.alpha)
      stdout.put(.alpha_beta)
      stdout.put(.alpha_beta_gamma)
      stdout.put(.alpha_beta_gamma_delta)
   end

   kd(i, j) result(res) ::: pure, selfless
   ! calculate the kronecker delta
      i, j :: INT, IN
      res :: INT
      res = 0
      if (i == j) res = 1
   end 

   t0(d) result(res) ::: pure, selfless
   ! calculate T elements of order 0 (point)
      d :: REAL, IN
      res :: REAL
      res = ONE/d
   end 

   t1(d, r) result(res) ::: pure, selfless
   ! calculate T elements of order 1 (dipole)
      d, r :: REAL, IN
      res :: REAL
      res = -r / (d**3)
   end 
   
   t2(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order 2 (quadrupole)
      d :: REAL, IN
      r :: VEC{REAL}(2), IN
      idx :: VEC{INT}(2), IN
      res :: REAL
      res = (THREE * r(1)*r(2)) - (d**TWO) * kd(idx(1),idx(2)) 
      res = res / (d**FIVE)
   end 

   t3(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order 3 (octupole)
      d :: REAL, IN
      r :: VEC{REAL}(3), IN
      idx :: VEC{INT}(3), IN
      res :: REAL
      d_12, d_13, d_23 :: INT
      d_12 = kd(idx(1),idx(2)); d_13 = kd(idx(1),idx(3))
      d_23 = kd(idx(2),idx(3))
      res = - 15d0 * r(1) * r(2) * r(2)
      res = res - THREE * d**TWO * (r(1)*d_23 + r(2)*d_13 + r(3)*d_12)
      res = res / d**7d0
   end 

   t4(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order (hexadecupole)
      d :: REAL, IN
      r :: VEC{REAL}(4), IN
      idx :: VEC{INT}(4), IN
      res :: REAL
      d_12, d_13, d_14, d_23, d_24, d_34 :: INT
      d_12 = kd(idx(1),idx(2)); d_13 = kd(idx(1),idx(3)); d_14 = kd(idx(1),idx(4))
      d_23 = kd(idx(1),idx(3)); d_24 = kd(idx(2),idx(4)); d_34 = kd(idx(3),idx(4))
      res = r(1)*r(2)*d_34 + r(1)*r(3)*d_24 + r(1)*r(4)*d_23 + r(2)*r(3)*d_14 + r(2)*r(4)*d_13 + r(3)*r(4)*d_12
      res = 105d0*r(1)*r(2)*r(3)*r(4) - res*(15d0*d**TWO) + (THREE*d**FOUR)*(d_12*d_23 + d_13*d_24 + d_14*d_23)
      res = res/d**NINE
   end 


   interaction_energy(charge_a, charge_b, dipole_a, dipole_b, quadrupole_a, quadrupole_b) result(res) ::: public
   ! calculate the expectation value of the interaction operator up to quadrupoles
      self :: IN
      charge_a, charge_b :: REAL, IN
      dipole_a, dipole_b :: VEC{REAL}(3), IN
      quadrupole_a, quadrupole_b :: MAT{REAL}(3,3), IN
      res :: REAL
      i,j,k,l :: INT
      u, uu, uq, qq :: REAL
      ! charge terms
      res = .scalar * charge_a * charge_b
      stdout.text("Dipole A")
      stdout.put(dipole_a)
      stdout.text("Dipole B")
      stdout.put(dipole_b)
      stdout.text("Quadrupole A")
      stdout.put(quadrupole_a)
      stdout.text("Quadrupole B")
      stdout.put(quadrupole_b)
      stdout.show("Charge term ", res)
      ! dipole terms
      u = ZERO
      do i = 1,3
         u = u + .alpha(i)*(charge_a*dipole_b(i) - dipole_a(i)*charge_b)
      end do
      stdout.show("Charge - dipole term ", u)
      ! quadrupole terms
      res = res + u
      u = ZERO
      uu = ZERO
      do i = 1,3
      do j = 1,3
         uu =  uu - .alpha_beta(i,j) * dipole_a(i)*dipole_b(j)
         u = u + .alpha_beta(i,j)*(THIRD*charge_a*quadrupole_b(i,j) + &
                                       THIRD*quadrupole_a(i,j)*charge_b)
      end do
      end do
      stdout.show("dipole-dipole term ", uu)
      stdout.show("Charge-quadrupole", u)
      uq = ZERO
      do i = 1,3
      do j = 1,3
      do k = 1,3
         uq = uq - THIRD * .alpha_beta_gamma(i,j,k)*(dipole_a(i)*quadrupole_b(j,k) - &
                                       quadrupole_a(i,j)*dipole_b(k))
      end do
      end do
      end do
      stdout.show("dipole-quadrupole", uq)
      qq = ZERO
      do i = 1,3
      do j = 1,3
      do k = 1,3
      do l = 1,3
         qq = qq + .alpha_beta_gamma_delta(i,j,k,l) * NINTH * quadrupole_a(i,j) * quadrupole_b(k,l)
      end do
      end do
      end do
      end do
      stdout.show("quadrupole-quadrupole", qq)
      res = res + u + uu + uq + qq
   end

end module
