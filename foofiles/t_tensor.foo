!-------------------------------------------------------------------------------
!
! T_TENSOR: produces the elements of cartesian interaction tensors aka 
! 'T tensors' used in electrodynamics
!
! Copyright (C) Peter Spackman, 2017
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!-------------------------------------------------------------------------------
module T_TENSOR
   implicit none

contains
   create(a, b)
   ! create the T tensors from two locations
      a, b :: VEC{REAL}(3), IN
      a_b :: VEC{REAL}(3)
      r :: REAL
      i, j, k, l :: INT
      a_b = b - a
      r = a_b.norm
      .scalar = t0(r)

      do i = 1, 3 
         .alpha(i) = t1(r, a_b(i))
      end do

      do i = 1, 3
      do j = 1, 3
         .alpha_beta(i,j) = t2(r, [a_b(i), a_b(j)], [i,j])
      end do
      end do

      do i = 1, 3
      do j = 1, 3
      do k = 1, 3
         .alpha_beta_gamma(i,j,k) = t2(r, [a_b(i), a_b(j), a_b(k)], [i,j,k])
      end do
      end do
      end do

      do i = 1, 3
      do j = 1, 3
      do k = 1, 3
      do l = 1, 3
         .alpha_beta_gamma_delta(i,j,k,l) = t2(r,[a_b(i),a_b(j),a_b(k),a_b(l)], [i,j,k,l])
      end do
      end do
      end do
      end do

   end

   kd(i, j) result(res) ::: pure, selfless
   ! calculate the kronecker delta
      i, j :: INT, IN
      res :: INT
      res = 0
      if (i == j) res = 1
   end 

   t0(d) result(res) ::: pure, selfless
   ! calculate T elements of order 0 (point)
      d :: REAL, IN
      res :: REAL
      res = ONE/d
   end 

   t1(d, r) result(res) ::: pure, selfless
   ! calculate T elements of order 1 (dipole)
      d, r :: REAL, IN
      res :: REAL
      res = -r / (d**3)
   end 
   
   t2(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order 2 (quadrupole)
      d :: REAL, IN
      r :: VEC{REAL}(2), IN
      idx :: VEC{INT}(2), IN
      res :: REAL
      res = (THREE * r(1)*r(2)) - (d**TWO) * kd(idx(1),idx(2)) / (d**FIVE)
   end 

   t3(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order 3 (octupole)
      d :: REAL, IN
      r :: VEC{REAL}(3), IN
      idx :: VEC{INT}(3), IN
      res :: REAL
      d_12, d_13, d_23 :: INT
      d_12 = kd(idx(1),idx(2)); d_13 = kd(idx(1),idx(3))
      d_23 = kd(idx(2),idx(3))
      res = - 15d0 * r(1) * r(2) * r(2)
      res = res - THREE * d**TWO * (r(1)*d_23 + r(2)*d_13 + r(3)*d_12)
      res = res / d**7d0
   end 

   t4(d, r, idx) result(res) ::: pure, selfless
   ! calculate T elements of order (hexadecupole)
      d :: REAL, IN
      r :: VEC{REAL}(4), IN
      idx :: VEC{INT}(4), IN
      res :: REAL
      d_12, d_13, d_14, d_23, d_24, d_34 :: INT
      d_12 = kd(idx(1),idx(2)); d_13 = kd(idx(1),idx(3)); d_14 = kd(idx(1),idx(4))
      d_23 = kd(idx(1),idx(3)); d_24 = kd(idx(2),idx(4)); d_34 = kd(idx(3),idx(4))
      res = r(1)*r(2)*d_34 + r(1)*r(3)*d_24 + r(1)*r(4)*d_23 + r(2)*r(3)*d_14 + r(2)*r(4)*d_13 + r(3)*r(4)*d_12
      res = 105d0*r(1)*r(2)*r(3)*r(4) - res*(15d0*d**TWO) + (THREE*d**FOUR)*(d_12*d_23 + d_13*d_24 + d_14*d_23)
      res = res/d**NINE
   end 

end module
