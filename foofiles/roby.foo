!---------------------------------------------------------------------------
!
!  ROBY:
!
!  Read and evaluate Roby atom data for population and bond analysis.
!  This module has been completely rewritten from Chris Taylor's version,
!  based on Steve Wolff's checked version.
!
! Copyright (C) Chris Taylor, UWA, 1999.
! Copyright (C) Stephen Wolff, UWA, 2000-2001.
! Copyright (C) Dylan Jayatilaka, 2001
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: roby.foo 4065 2013-06-17 15:38:05Z dylan_ $
!---------------------------------------------------------------------------

module ROBY

   implicit none

contains

!  ===================
!  Allocation routines
!  ===================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   create(mol) ::: leaky
   ! Create space for the object
      self :: PTR
      mol :: MOLECULE

      .create
      .set_defaults(mol)

   end

   destroy ::: leaky
   ! Destroy space for an SCF type
      self :: PTR

      if (.disassociated) return

      .nullify_ptr_data

      .destroy_ptr_part

      deallocate(self)

   end

   created result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has *not* been created
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self

      nullify(.n1)
      nullify(.n2)
      nullify(.bond_index)
      nullify(.cov_index)
      nullify(.ion_index)
      nullify(.percent_covalency)
      nullify(.gould_charge)
      nullify(.cruickshank_charge)
      nullify(.summed_n2)
      nullify(.summed_n3)
      nullify(.subgroup_pop)
      nullify(.atom_list)

      nullify(.theta_C)
      nullify(.eval_C)
      nullify(.theta_I)
      nullify(.eval_I)
      nullify(.pop_C)
      nullify(.pop_I)
      nullify(.pop_A)
      nullify(.pop_B)
      nullify(.covalent_index)
      nullify(.ionic_index)
      nullify(.proportion_a)
      nullify(.pair)

      nullify(.rho)
      nullify(.overlap_matrix)
      nullify(.atom)

   end

   nullify_ptr_data
   ! Nullify the pointer data that is supposed to come from outside
   ! this module, so that this data is *not* accidentally destroyed

      nullify(.rho)
      nullify(.atom)
      nullify(.overlap_matrix)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self

      .n1.destroy
      .n2.destroy
      .bond_index.destroy
      .cov_index.destroy
      .ion_index.destroy
      .percent_covalency.destroy
      .gould_charge.destroy
      .cruickshank_charge.destroy
      .summed_n2.destroy
      .summed_n3.destroy
      .subgroup_pop.destroy
      .atom_list.destroy

      .theta_C.destroy
      .eval_C.destroy
      .theta_I.destroy
      .eval_I.destroy
      .pop_C.destroy
      .pop_I.destroy
      .pop_A.destroy
      .pop_B.destroy
      .covalent_index.destroy
      .ionic_index.destroy
      .proportion_a.destroy
      .pair.destroy

      ! Never destroy these.
      nullify(.rho)
      nullify(.atom)
      nullify(.overlap_matrix)

   end

   set_defaults
   ! Set default SCF data values
      self :: INOUT

      .roby_kind = "bond_and_charge_analysis"

      .covalent_cutoff        = ROBY_COVALENT_CUTOFF*RADIAN_PER_DEGREE
      .ionic_cutoff           = ROBY_IONIC_CUTOFF   *RADIAN_PER_DEGREE
      .zero_cutoff            = ROBY_ZERO_CUTOFF    *RADIAN_PER_DEGREE
      .pi_on_2_cutoff         = ROBY_PI_ON_2_CUTOFF *RADIAN_PER_DEGREE

      .occupied_ANO_cutoff    = ROBY_OCCUPIED_ANO_CUTOFF
      .output_theta_info      = ROBY_OUTPUT_THETA_INFO
      .analyze_all_atom_pairs = ROBY_ANALYZE_ALL_ATOM_PAIRS
      .bond_range_factor      = ROBY_BOND_RANGE_FACTOR

   end

   set_defaults(mol)
   ! Set default SCF data values
      mol :: MOLECULE

   ENSURE(mol.atom.associated,"no atom list") 
   ENSURE(mol.density_matrix.associated,"no density matrix") 
   ENSURE(mol.overlap_matrix.associated,"no overlap matrix") 

      .set_defaults

      .charge            =  mol.charge
      .spin_multiplicity =  mol.spin_multiplicity

      .atom              => mol.atom
      .rho               => mol.density_matrix
      .overlap_matrix    => mol.overlap_matrix

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                      ")  ! exit case
         case ("analyze_all_atom_pairs="); .read_analyze_all_atom_pairs
         case ("atom_groups=           "); .read_atom_groups
         case ("atom_list=             "); .read_atom_list
         case ("bond_scale_factors=    "); .read_bond_scale_factor
         case ("covalent_cutoff=       "); .read_covalent_cutoff
         case ("ionic_cutoff=          "); .read_ionic_cutoff
         case ("kind=                  "); .read_kind
         case ("output_theta_info=     "); .read_output_theta_info
         case ("pi_on_2_cutoff=        "); .read_pi_on_2_cutoff
         case ("zero_cutoff=           "); .read_zero_cutoff
         case default;           UNKNOWN(word)
      end

   end

   finalize ::: selfless, leaky ::: PURE
   ! Make sure the input satisfies sanity checks and generate any other
   ! missing data

   ENSURE(.roby_kind/=" ","no calculation kind specified")
   ENSURE(.atom.associated,"no atom data supplied")
   ENSURE(.atom_list.associated NEQV .atom_group.created,"atom_list and atom_group both used!")

   end

   read_kind
   ! Read the SCF type

      stdin.read(.roby_kind)

      select case (.roby_kind)
         case("atom_bond_analysis     ")
         case("group_bond_analysis    ")
         case default;    UNKNOWN(.roby_kind)
      end

   end

   read_atom_list ::: leaky
   ! Read the list of atoms indices defining a Roby group
      stdin.read_ptr(.atom_list)
   end

   read_atom_groups ::: leaky
   ! Read the list of atoms indices defining a Roby group
      stdin.read_ptr(.atom_group)
   end

   read_covalent_cutoff
   ! Angles (in radians) greater than this one inputted are ignored when
   ! calculating the covalent bond index
      stdin.read_quantity(.covalent_cutoff)
   end

   read_ionic_cutoff
   ! Angles (in radians) greater than this one inputted are ignored when
   ! calculating the ionic bond index
      stdin.read_quantity(.ionic_cutoff)
   end

   read_pi_on_2_cutoff
   ! Angles (in radians) greater than this one inputted are not used to
   ! calculate the bond index

      stdin.read_quantity(.pi_on_2_cutoff)

      .ionic_cutoff    = .pi_on_2_cutoff
      .covalent_cutoff = .pi_on_2_cutoff

   end

   read_zero_cutoff
   ! Angles (in radians) *less* than this one inputted are regareded as zero
      stdin.read_quantity(.zero_cutoff)
   end

   read_output_theta_info
   ! Read in a switch which tells whether to output detailed theta-subspace
   ! bond information
      stdin.read(.output_theta_info)
   end

   read_analyze_all_atom_pairs
   ! Read in a switch which tells whether to bond-analyze all atoms
   ! pairs or not - actually this just changes the bond_range_factor
   ! by an order of magnitude
      self :: INOUT

      stdin.read(.analyze_all_atom_pairs)

      if (.analyze_all_atom_pairs) then
         .bond_range_factor = FIVE*BOHR_PER_ANGSTROM
      end

   end

   read_bond_scale_factor
   ! Read in a bond scale factor used to multiply the sum of the
   ! Bragg-Slater radii for two atoms, to determine a distance cutoff
   ! within which atoms are regarded to be bonded
      self :: INOUT

      stdin.read(.bond_range_factor)

   end

!  ===================
!  Information methods
!  ===================

   is_homoleptic result (res) ::: pure
   ! Returns TRUE if the calculation data is "homoleptic" or not
   ! i.e. involving groups of atoms
      self :: IN
      res :: BIN

      res = .atom_list.disassociated

   end

   skip_pair(a,b) result (res) ::: private, pure
   ! Returns TRUE if the bond index calculation should skip the pair of groups
   ! (a,b). For calculations which are homoleptic, this always returns FALSE, but
   ! for calculations which are defined by an atom_list, this returns TRUE only if
   ! .analyze_all_atom_pairs is set to FALSE and the atoms are regarded as bonded
   ! according to the .bond_range_factor distance cutoff.
      self :: IN
      a,b :: INT, IN
      res :: BIN

      if      (.is_homoleptic) then;          res = FALSE
      else if (.analyze_all_atom_pairs) then; res = FALSE
      else
         res = NOT .atom.bonded(a,b,.bond_range_factor)
      end

   end

   n_bf(group) result (res) ::: private, PURE
   ! Return the number of basis functions in the atom group
   ! whose indices are given in "group"; but if "group" is
   ! not present return the dimension of the full overlap matrix.
      self :: IN
      group :: VEC{INT}, optional, IN
      res :: INT

   ENSURE(.atom.associated,"No atom information")
   ENSURE(.overlap_matrix.associated,"No overlap matrix")

      if (present(group)) then; res = .atom(group).n_bf
      else;                     res = .overlap_matrix.dim1
      end

   end

   n_bf_a result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_a group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_a.created,"No atom A group")

      res = .n_bf(.atom_a)

   end

   n_bf_b result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_b.created,"No atom B group")

      res = .n_bf(.atom_b)

   end

   n_bf_ab result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_ab.created,"No atom AB group")

      res = .n_bf(.atom_ab)

   end

   n_group result (res) ::: private, PURE
   ! Return the number of roby atom groups
      self :: IN
      res :: INT

   ENSURE(.atom_group.created,"no atom groups!")

      res = .atom_group.dim

   end

   no_of_occupied_ANOs(group,tol) result (res) ::: private, PURE
   ! Return the number of occupied atomic natural orbitals for
   ! the group of atoms whose indices are in "group"
      self :: IN
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.atom.associated,"no atom information")

      eps :: REAL

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      res = .atom(group).no_of_occupied_ANOs(tol=eps)

   end

   unique_tags result (res) ::: leaky
   ! Return a list of unique tags for the atom groups
      self :: IN
      res :: VEC{STR}*

      symbols :: VEC{STR}*
      g :: INT

      if (.is_homoleptic) then
         res.create(.atom_group.dim)
         do g = 1,.atom_group.dim
            symbols => .atom(.atom_group(g).element).unique_tags
            res(g)  = VEC{STR}:to_concatenated_str(symbols)
            symbols.destroy
         end
      else
         res => .atom(.atom_list).unique_tags
      end

   end

! ============
! Main methods
! ============

   atom_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

   ENSURE(.atom_list.associated,"no atom list")
   ENSURE(.atom_group.destroyed,"do not use atom_group=")

      .make_single_atom_groups
      .group_bond_analysis

   end

   group_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

      .bond_analysis
    ! .charge_analysis
      .put_all_info

   end

! =================================
! Roby population analysis routines
! =================================

   make_single_atom_groups ::: leaky, private
   ! Make each Roby atom to be equal to a single atom formed from
   ! each element in the ".atom_list".

   ENSURE(.atom_list.associated,"no atom list")
   ENSURE(.atom_group.destroyed,"do not use atom_groups=")

      n_atom,a :: INT

      n_atom = size(.atom_list)

      .atom_group.create(n_atom)

      do a = 1,n_atom
         .atom_group(a).element.create(1)
         .atom_group(a).element(1) = .atom_list(a)
      end

   end

   make_populations ::: leaky, private
   ! Make the Roby populations for the defined atom groups, for a
   ! given density matrix "rho"
      self :: INOUT

   ENSURE(.atom_group.created,"no atom groups")
   ENSURE(.rho.associated,"no rho matrix")

      a :: INT

      ! Population array
      .n1.destroy
      .n1.create(.n_group)

      do a = 1,.n_group

         ! Set V_A
         .atom_a = .atom_group(a).element

         ! Get the population
         .n1(a)  = .population(.atom_a)

         ! Clean
         .atom_a.destroy

      end

   end

   make_pair_populations ::: leaky, private
   ! Make the pair Roby populations
      self :: INOUT

      n_group,a,b :: INT
      pop :: REAL

      ! No. of subspaces
      n_group = .n_group

      ! Pair population array
      .n2.destroy
      .n2.create(n_group,n_group)
      .n2 = ZERO

      do a = 1,n_group
      do b = 1,a-1

         if (.skip_pair(a,b)) cycle
         
         ! Assign V_A & V_B atom subspaces
         .atom_a = .atom_group(a).element
         .atom_b = .atom_group(b).element
         
         ! Define V_AB = V_A u V_B
         .atom_ab.append(.atom_a,.atom_b)

         ! Get population
         pop = .population(.atom_ab)
         .n2(a,b) = pop
         .n2(b,a) = pop
         
         ! Clean
         .atom_a.destroy
         .atom_b.destroy
         .atom_ab.destroy

      end
      end

   end

   population(group,ANO) result (res) ::: private
   ! Return the total Roby population for the group of atoms whose indices are
   ! given in "group", i.e Tr (P_{group;ANO} rho), where "rho" is the density
   ! matrix for a molecule. If present, the columns of the "ANO" matrix are used
   ! to define the Roby projector instead of the atomic natural orbitals.
      self :: INOUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      res :: REAL

   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

      X :: MAT{REAL}*
      n_gr :: INT

      n_gr = .n_bf(group)

      X.create(n_gr,n_gr)

      .make_projection_matrix(X,group,ANO)

      res = .expectation(X,group)

      X.destroy

   end

!   subpopulation(subgroup,group,ANO) result (res) ::: private
!   ! Return the Roby subpopulation for the subgroup of atoms whose indices are
!   ! given in "subgroup", in the whole group of atoms whose indices are
!   ! are given in "group", i.e
!   !    Tr ( P_{subgroup} P_{group;ANO} P_{subgroup} rho )
!   ! If present, the columns of the "ANO" matrix are used to define the middle
!   ! Roby projector instead of the atomic natural orbitals. Note that the
!   ! real atomic natural orbitals are always used for the P_{subgroup}
!   ! projector.  This routine is useful for getting theta orbital populations.
!      self :: INOUT
!      subgroup :: VEC{INT}, IN
!      group :: VEC{INT}, IN
!      ANO :: MAT{REAL}, optional, IN
!      res :: REAL
!
!   ENSURE(.rho.associated,"no rho matrix")
!   ENSURE(.overlap_matrix.associated,"no overlap matrix")
!
!      P,X,P_sub :: MAT{REAL}*
!      n_gr,n_sub :: INT
!
!      n_gr  = .n_bf(group)
!      n_sub = .n_bf(subgroup)
!
!      X.create(n_sub,n_sub)
!      P.create(n_gr,n_gr)
!      P_sub.create(n_sub,n_sub)
!
!      .make_projection_matrix(P,group,ANO)
!      .make_projection_matrix(P_sub,subgroup)
!      .project(P,P_sub,X,group,subgroup)
!
!      P_sub.destroy
!      P.destroy
!
!      res = .expectation(X,subgroup)
!
!      X.destroy
!
!   end

! ================================
! Roby multiple shared populations
! ================================

!   make_shared_population ::: leaky, private
!   ! Evaluate the Roby shared population
!
!   ENSURE(.atom_group.associated,"no atom group supplied")
!
!      n_group,i :: INT
!
!      n_group = .n_group
!
!      .subgroup_pop.destroy
!      .subgroup_pop.create(n_group)
!
!      i = 0
!      .n_shared = .shared_population([(i,i=1,n_group)], .subgroup_pop)
!
!   end

!   shared_population(group_list,pop_groups) result (res) ::: private
!   ! Returns the Roby shared population of the group of .atom_groups whose
!   ! indices are in "group". If "pop_groups" is present, the total
!   ! sub-group populations of every size from 1 to size(group) is returned
!      group_list :: VEC{INT}
!      pop_groups :: VEC{REAL}, optional
!      res :: REAL
!
!   ENSURE(.atom_group.associated,"no atom groups")
!
!      pop_k :: REAL
!      m, k, n_k, n :: INT
!      comb_mat :: MAT{INT}*
!      pop_group :: VEC{REAL}*
!
!      n = size(group_list)
!
!      pop_group.create(n)
!
!      res = ZERO
!      do k = 1,n
!
!         n_k = int(n.choose(k))
!
!         ! Make "comb_mat", the matrix of all combinations of the groups
!         ! of size k, where the groups are taken from .atom_group
!         comb_mat.create(k,n_k)
!         group_list.make_combinations_of_length(k,comb_mat)
!
!         pop_k = 0
!         do m = 1,n_k
!            .atom_group.append_listed_to(.atom_ab,list=comb_mat(:,m))
!            pop_k = pop_k + .population(.atom_ab)
!            .atom_ab.destroy
!         end
!         pop_group(k) = pop_k
!
!         comb_mat.destroy
!
!         res = res - ((-1)**k)*pop_k
!
!      end
!
!      if (present(pop_groups)) pop_groups = pop_group
!
!      pop_group.destroy
!
!   end

!   make_summed_pair_pops ::: leaky, private
!   ! Evaluate the SUMMED Roby shared populations for groups of 2 atoms.
!   ! On return, .summed_n2(a) = \sum_{b} s_{ab}, where s_{ab} is the pairwise
!   ! shared population for atoms a, b.
!
!   ENSURE(.n1.associated,"no group populations")
!   ENSURE(.n2.associated,"no group pair populations")
!
!      shared_population :: REAL
!      n_group,a,b :: INT
!
!      n_group = .n_group
!      .summed_n2.create(n_group)
!
!      .summed_n2 = ZERO
!
!      do a = 1,n_group
!      do b = a+1,n_group
!         shared_population = .n1(a) + .n1(b) - .n2(a,b)
!         .summed_n2(a)     = .summed_n2(a) + shared_population
!         .summed_n2(b)     = .summed_n2(b) + shared_population
!      end
!      end
!
!   end

!   make_summed_triple_pops ::: leaky, private
!   ! Evaluate the SUMMED Roby shared populations for groups of 3 atoms.
!   ! On return, .summed_n3(a) = \sum_{bc} s_{abc}, where s_{abc} is the triple
!   ! shared population for atoms a, b, and c.
!
!      shared_population :: REAL
!      n_group,a,b,c :: INT
!
!      n_group = .n_group
!      .summed_n3.create(n_group)
!
!      .summed_n3 = ZERO
!
!      do a = 1  ,n_group
!      do b = a+1,n_group
!      do c = b+1,n_group
!         shared_population = .shared_population([a,b,c])
!         .summed_n3(a)     = .summed_n3(a) + shared_population
!         .summed_n3(b)     = .summed_n3(b) + shared_population
!         .summed_n3(c)     = .summed_n3(c) + shared_population
!      end
!      end
!      end
!
!   end

! ==============================
! Roby-Gould bond index routines
! ==============================

   bond_analysis ::: leaky, private
   ! Do a Roby-Gould bond and charge analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.created,"no atom group defined")

      n_group,a,b :: INT
      ind,pcc,cov,ion :: REAL

      ! NO of subspaces
      n_group = .n_group

      ! Make populations
      .make_populations
      .make_pair_populations

      ! Bond index arrays
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency.create(n_group,n_group)

      do a = 1,n_group
      do b = 1,a-1

        if (.skip_pair(a,b)) cycle

        ! Set V_A, V_B and V_AB 
        .atom_a = .atom_group(a).element
        .atom_b = .atom_group(b).element
        .atom_ab.append(.atom_a,.atom_b)

        ! Make V_theta bond subspace info
        .destroy_theta_info
        .make_theta_info

        ! Do bond indices
        ind  = .gould_bond_index(cov,ion,pcc)

        .bond_index(a,b)        =  ind
        .cov_index(a,b)         =  cov
        .ion_index(a,b)         =  ion
        .percent_covalency(a,b) =  pcc

        .bond_index(b,a)        =  ind
        .cov_index(b,a)         =  cov
        .ion_index(b,a)         = -ion
        .percent_covalency(b,a) =  pcc

        ! Output V_theta info?
        if (.output_theta_info) then
           .put_theta_info
           .put_theta_bond_info
        end
        .destroy_theta_info

        ! Clean
        .atom_a.destroy
        .atom_b.destroy
        .atom_ab.destroy

      end
      end

   end

   gould_bond_index(c_ab,i_ab,pcc) result (bond_index) ::: leaky, private
   ! Calculates the Roby-Gould "bond_index", percentage covalent character
   ! "pcc", for atom groups ".atom_a" and ".atom_b".
      self :: INOUT
      c_ab,i_ab,pcc :: REAL, OUT
      bond_index :: REAL

   ENSURE(.theta_angle.associated,"no theta angles")
   ENSURE(.pop_C.associated,"no covalent theta populations")
   ENSURE(.pop_I.associated,"no ionic theta populations")
   ENSURE(.pair.associated,"no pair array")

      n_ab,i :: INT
      ionic_cutoff,covalent_cutoff,zero_cutoff,angle :: REAL

      ionic_cutoff    = .ionic_cutoff.to_units("degree")
      covalent_cutoff = .covalent_cutoff.to_units("degree")
      zero_cutoff     = .zero_cutoff.to_units("degree")

      n_ab = .n_bf_ab

      .covalent_index.create(n_ab)
      .ionic_index.create(n_ab)

      .covalent_index = ZERO
      .ionic_index    = ZERO
      pcc = ZERO
      c_ab = ZERO
      i_ab = ZERO
      bond_index = ZERO

      do i = 1,n_ab

        if (.pair(i)<1 OR i<.pair(i)) cycle

        angle = .theta_angle(i)

        .covalent_index(i) = (.pop_C(i) - .pop_C(.pair(i)))/TWO
        .ionic_index(i)    = (.pop_I(i) - .pop_I(.pair(i)))/TWO

        if (angle <= covalent_cutoff AND angle >= zero_cutoff) c_ab = c_ab + .covalent_index(i)
        if (angle <= ionic_cutoff    AND angle >= zero_cutoff) i_ab = i_ab + .ionic_index(i)

      end

      bond_index = c_ab**2 + i_ab**2
      pcc        = 100 * (c_ab**2/bond_index)
      bond_index = sqrt(bond_index)

   end

   make_theta_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom groups
   ! ".atom_a" and ".atom_b", including theta subspace populations
      self :: INOUT

   ENSURE(.atom_a.created,"no atom A group")
   ENSURE(.atom_b.created,"no atom B group")
   ENSURE(.atom_ab.created,"no atom AB group")

      C :: MAT{REAL}*
      n_a,n_b,n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = n_a + n_b

      ! Make the Roby operator
      C.create(n_ab,n_ab)                      
      .make_shared_operator(C)

      ! Covalent operator
      .theta_C.create(n_ab,n_ab)
      .eval_C.create(n_ab)
      .diagonalize_V_AB_operator(C,.theta_C,.eval_C)

      ! Find +/- pairs covalent pairs
      ! Make |cov-> from |cov+>
      .theta_angle.create(n_ab)
      .pair.create(n_ab)
      .eval_C.find_pairs(.pair,ROBY::match_pair)
      .make_theta_angles
      .make_gould_covalent_orbitals

      ! Ionic operator
      ! Make |ion> pairs from |cov> pairs
      .theta_I.create(n_ab,n_ab)
      .eval_I.create(n_ab)
      .make_gould_ionic_orbitals

      ! Make covalent/ionic theta populations
      .pop_C.create(n_ab)
      .pop_I.create(n_ab)
      .make_theta_populations(.pop_C,.theta_C) 
      .make_theta_populations(.pop_I,.theta_I)

      C.destroy

   end

   destroy_theta_info ::: leaky, private
   ! Delete all the temporary theta subspace information created by various bond
   ! index routines
      .ionic_index.destroy
      .covalent_index.destroy
      .pop_B.destroy
      .pop_A.destroy
      .pop_I.destroy
      .pop_C.destroy
      .eval_I.destroy
      .theta_I.destroy
      .pair.destroy
      .theta_angle.destroy
      .eval_C.destroy
      .theta_C.destroy
   end

   match_pair(arg1,arg2) result (res) ::: selfless, private
   ! Function which returns zero if "arg1" and "arg2" are opposite.
   ! Used for matching purposes.
      arg1,arg2,res :: REAL
      res = abs(arg1 + arg2)
   end

   make_theta_populations(pop,theta) ::: private
   ! Make "pop", an array of "theta" populations for a pair of Roby atoms
   ! defined by indices in ".atom_a" and ".atom_b". "theta" itself is a matrix
   ! whose columns are coefficients on V_AB.
      self :: INOUT
      pop :: VEC{REAL}, OUT
      theta :: MAT{REAL}, IN

   ENSURE(.atom_ab.created,"No roby atom group AB")
   ENSURE(pop.dim==.n_bf_ab,"wrong size, pop")

      i :: INT

      do i = 1,.n_bf_ab
         pop(i) = .population(.atom_ab,ANO=theta(:,i:i))
      end

   end

!   make_theta_atom_populations(pop_a,pop_b,theta) ::: private
!   ! Make "pop_a" and "pop_b", the "theta" populations of the Roby atoms
!   ! ".atom_a" and ".atom_b". "theta" itself is a matrix whose columns are
!   ! coefficients on V_AB.
!      pop_a,pop_b :: VEC{REAL}
!      theta :: MAT{REAL}
!
!   ENSURE(pop_a.dim==.n_bf_ab,"wrong size, theta_a_population")
!   ENSURE(pop_b.dim==.n_bf_ab,"wrong size, theta_b_population")
!   ENSURE(.atom_a.associated, "No roby atom group A")
!   ENSURE(.atom_b.associated, "No roby atom group B")
!   ENSURE(.atom_ab.associated,"No roby atom group AB")
!
!      i :: INT
!
!      do i = 1,.n_bf_ab
!         pop_a(i) = .subpopulation(.atom_a,.atom_ab,ANO=theta(:,i:i))
!         pop_b(i) = .subpopulation(.atom_b,.atom_ab,ANO=theta(:,i:i))
!      end
!
!   end

   make_theta_angles ::: private
   ! Make the ".theta_angle" array from the Roby eigenvalues ".eval_C"
   ENSURE(.eval_C.associated,"No roby eigenvalues")
   ENSURE(.theta_angle.associated,"No theta_angle array")
       i :: INT
      value :: REAL
      do i = 1,.n_bf_ab
        value = abs(.eval_C(i))
        value = value.arccos
        value = value.to_units("degree")
        .theta_angle(i) = value
      end
   end

   make_gould_covalent_orbitals ::: private
   ! Generate the gould covalent orbitals ".theta_C" in such a way that the
   ! negative eigenvector of each pair is generated explicitly from the positive
   ! eigenvector by constructing the |a> and |b> parts using projectors P_A and
   ! P_B. ".eval_C" are the eigenvalues corresponding to ".theta_C". ".pair" is
   ! defined so that the i-th eigenvector .theta_C(:,i) is paired with
   ! theta_C(:,pair(i)). The spaces V_A , V_B and V_AB are defined by
   ! ".atom_a", ".atom_b", and ".atom_ab". This routine is necessary in the case
   ! where there are degeneracies.
      self :: INOUT

   ENSURE(.atom_a.created,"No roby atom A")
   ENSURE(.atom_b.created,"No roby atom B")
   ENSURE(.atom_ab.created,"No roby atom AB")
   ENSURE(.atom.associated,"No atom information")
   ENSURE(.theta_C.associated,"No theta_C array")
   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
   ENSURE(.theta_C.is_square,"wrong shape, theta_C")
   ENSURE(.eval_C.associated,"No eval_C array")
   ENSURE(.eval_C.dim==.n_bf_ab,"wrong shape, eval_I")
   ENSURE(.pair.associated,"No pair array")
   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")

      P_A,PA,P_B,PB :: MAT{REAL}*
      A,B :: VEC{REAL}*
      n_a,n_b,n_ab,i :: INT
      fac,costheta :: REAL

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab
      P_A.create(n_a,n_a); PA.create(n_a,n_ab)
      P_B.create(n_b,n_b); PB.create(n_b,n_ab)
      A.create(n_a)
      B.create(n_b)
      .make_projection_matrix(P_A,.atom_a)
      .make_projection_matrix(P_B,.atom_b)
      .right_overlap_transform(P_A,PA,.atom_a,.atom_ab)
      .right_overlap_transform(P_B,PB,.atom_b,.atom_ab)
      do i = 1,n_ab
         if (.pair(i)<1) cycle
         if (.eval_C(i)<.eval_C(.pair(i))) cycle
         costheta = .eval_C(i)
         fac = sqrt(TWO+TWO*costheta)/(ONE+costheta)
         A.to_product_of(PA,.theta_C(:,i)); A = fac*A
         B.to_product_of(PB,.theta_C(:,i)); B = fac*B
         fac = ONE/sqrt(TWO-TWO*costheta)
         .theta_C(    1:n_a ,.pair(i)) =  fac*A
         .theta_C(n_a+1:n_ab,.pair(i)) = -fac*B
      end
      B.destroy
      A.destroy
      PB.destroy; P_B.destroy
      PA.destroy; P_A.destroy
   end

   make_gould_ionic_orbitals ::: private
   ! Make the gould ionic orbitals ".theta_I" and eigenvalues ".eval_I"
   ! from the covalent orbitals ".theta_C" and covalent eigenvalues
   ! ".eval_C" which have been explicitly paired up as described by
   ! the ".pair" array. ALSO: the ".pair" array is modified to remove all
   ! those pairs which have zero sine and cosine eigenvalues.

   ENSURE(.theta_C.associated,"no theta_C array")
   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
   ENSURE(.theta_C.is_square,"wrong shape, theta_C")
   ENSURE(.theta_I.associated,"no theta_I array")
   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong shape, theta_I")
   ENSURE(.theta_I.is_square,"wrong shape, theta_I")
   ENSURE(.eval_I.associated,"no eval_I array")
   ENSURE(.eval_I.dim==.n_bf_ab,"wrong shape, eval_I")
   ENSURE(.eval_C.associated,"no eval_C array")
   ENSURE(.eval_C.dim==.n_bf_ab,"wrong shape, eval_I")
   ENSURE(.pair.associated,"no pair array")
   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")

      fac,eps :: REAL
      n_ab,i,j :: INT
      eval :: MAT{REAL}(1,1)
      ZZ,II :: MAT{REAL}*

      n_ab = .pair.dim
      eps = .zero_cutoff

      ZZ.create(n_ab,n_ab)
      II.create(n_ab,n_ab)

      .make_ionic_operator(II)
      .overlap_transform(II,ZZ,.atom_ab,.atom_ab)

      II.destroy

      .theta_I = ZERO
      .eval_I = ZERO

      do i = 1,n_ab

         if (.pair(i)<1) cycle
         if (.eval_C(i)<.eval_C(.pair(i))) cycle

         j = .pair(i)
         fac = ONE/sqrt(TWO)
         .theta_I(:,i) = fac*(.theta_C(:,i)+.theta_C(:,j)) ! I+
         .theta_I(:,j) = fac*(.theta_C(:,i)-.theta_C(:,j)) ! I-
         ZZ.change_basis_to(eval,.theta_I(:,i:i)); .eval_I(i) = eval(1,1)
         ZZ.change_basis_to(eval,.theta_I(:,j:j)); .eval_I(j) = eval(1,1)
         if (.eval_C(i).is_zero(eps) AND .eval_I(i).is_zero(eps)) then
            .pair(i) = 0
            .pair(j) = 0
         end

      end

      ZZ.destroy

   end

!   charge_analysis ::: leaky, private
!   ! Do a Roby-Cruickshank-Avramedes and Roby-Gould charge analysis.
!   ! NOTE: This can only be called after a bond analysis because the atom
!   ! proportions are required.
!   ENSURE(.atom_group.associated,"no atom groups")
!   ENSURE(.n1.associated,"no atom populations")
!
!      n_group,a,b :: INT
!      rsa,rsb,charge_deficit,fac :: REAL
!
!      n_group = .n_group
!      .proportion_a.create(n_group,n_group)
!
!      .proportion_a = ZERO
!
!      do a = 1,n_group
!      do b = 1,a-1
!
!        if (.skip_pair(a,b)) cycle
!
!        .atom_a => .atom_group(a).element
!        .atom_b => .atom_group(b).element
!        .atom_ab.append(.atom_a,.atom_b)
!
!        .destroy_theta_info
!        .make_theta_info
!
!        ! Store for later charge analysis
!        .make_atom_proportions(rsa,rsb) 
!        .proportion_a(a,b) = rsa
!        .proportion_a(b,a) = rsb
!      ! if (.output_theta_info) .put_theta_atom_pops
!        .destroy_theta_info
!
!        nullify(.atom_a)
!        nullify(.atom_b)
!        .atom_ab.destroy
!
!      end
!      end
!
!      .make_populations
!
!      .make_pair_populations
!
!      .make_summed_pair_pops
!
!      .make_summed_triple_pops
!
!      ! Roby-Gould atomic charges
!      .gould_charge.create(n_group)       
!      do a = 1,n_group
!        .gould_charge(a) = .atom(.atom_group(a).element).sum_of_nuclear_charges &
!                         - .n1(a) + VEC{REAL}:sum_elements(.proportion_a(:,a)) - THIRD*.summed_n3(a)
!      end
!      fac = ONE/REALIFY(n_group)
!      charge_deficit = .charge - VEC{REAL}:sum_elements(.gould_charge)
!      charge_deficit = fac*charge_deficit
!      .gould_charge = .gould_charge + charge_deficit
!
!      ! Cruickshank atomic charges
!      .cruickshank_charge.create(n_group) 
!      do a = 1,n_group
!        .cruickshank_charge(a) = .atom(.atom_group(a).element).sum_of_nuclear_charges &
!                               - .n1(a) + HALF*.summed_n2(a) - THIRD*.summed_n3(a)
!      end
!      fac = ONE/REALIFY(n_group)
!      charge_deficit = .charge - VEC{REAL}:sum_elements(.cruickshank_charge)
!      charge_deficit = fac*charge_deficit
!      .cruickshank_charge = .cruickshank_charge + charge_deficit
!
!   end

!   make_atom_proportions(rsa,rsb) ::: leaky, private
!   ! Make Gould's probabilistic proportionalities between atoms,
!   ! ".proportion_a" and ".proportion_b" used to approtion charge
!   ! between atoms, i.e. calculate
!   ! rsa = \sum_{\theta} r^{\theta}_{A,AB} s^{\theta}_{AB}
!   ! rsb = \sum_{\theta} r^{\theta}_{B,AB} s^{\theta}_{AB}
!      rsa, rsb :: REAL
!
!   ENSURE(.theta_C.associated,"no theta_C covalent orbitals")
!   ENSURE(.eval_C.associated,"no eval_C covalent eigenvalues")
!   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
!
!      n_ab,i :: INT
!      pop_a, pop_b, pop_ab, s_ab, ratio_a, ratio_b :: REAL
!
!      n_ab = .n_bf_ab
!
!      .pop_A.create(n_ab)
!      .pop_B.create(n_ab)   
!      
!      ! Make A & B theta popualtions
!      .make_theta_atom_populations(.pop_A,.pop_B,.theta_C)
!
!      rsa = ZERO
!      rsb = ZERO
!
!      do i = 1,n_ab
!
!         if (.pair(i)<1 OR i<.pair(i)) cycle
!
!         pop_a   = .pop_A(i) + .pop_A(.pair(i))
!         pop_b   = .pop_B(i) + .pop_B(.pair(i))
!         pop_ab  = .pop_C(i) + .pop_C(.pair(i))
!         ratio_a = pop_a/(pop_a + pop_b)
!         ratio_b = pop_b/(pop_a + pop_b)
!         s_ab    = pop_a + pop_b - pop_ab
!         rsa     = rsa + ratio_a*s_ab
!         rsb     = rsb + ratio_b*s_ab
!
!      end
!
!   end

! ===================================
! Make and diagonalise Roby operators
! ===================================

   make_projection_matrix(P,group,ANO) ::: private
   ! Make the Roby projection matrix "P" in the AO basis made from the
   ! concatenated basis sets for each atom in "group". If present, use
   ! the columns of "ANO" as atomic orbital coefficients to form the
   ! projection operator instead of the actual atomic natural orbitals
      self :: IN
      P :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(P.dim1==.n_bf(group),"wrong dimension, P ")
   ENSURE(P.is_square,"P is incorrectly dimensioned")

      W,X,Y :: MAT{REAL}*
      n_occ,n_bf :: INT

      n_bf = .n_bf(group)


      ! W = columns of ANO's
      if (present(ANO)) then
         ENSURE(ANO.dim1==.n_bf(group),"wrong dimension, ANO")
         n_occ = ANO.dim2
         W.create(n_bf,n_occ)
         W = ANO
      else
         n_occ = .no_of_occupied_ANOs(group)
         W.create(n_bf,n_occ)
         .make_ANO_matrix(W,group)
      end

      ! Y = overlap matrix for group(:) basis
      Y.create(n_bf,n_bf)                   
      .make_overlap_matrix(Y,group,group)

      ! X = S in the ANO basis
      X.create(n_occ,n_occ)
      Y.change_basis_to(X,W)
      Y.destroy

      ! Y = (ANO overlap matrix)^{-1}
      Y.create(n_occ,n_occ)
      Y.to_pseudo_inverse_of(X)
      X.destroy

      ! P = Y in the group(:) AO basis
      Y.back_transform_to(P,W)

      ! Clean
      Y.destroy
      W.destroy

   end

   make_ANO_matrix(ANO,group,tol) ::: private, PURE
   ! Make the "ANO" matrix, comprised of columns of the occupied atomic
   ! natural orbitals, for each atom whose index appears in "group".
   ! If "tol" is present, use this cutoff to determine what is an occupied
   ! natural orbital.
      self :: IN
      ANO :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN

   ENSURE(ANO.dim1==.n_bf(group),"wrong shape, ANO")
   ENSURE(ANO.dim2==.no_of_occupied_ANOs(group,tol),"wrong shape, ANO")

      eps :: REAL
      a,aa,b,n,n_bf,n_occ :: INT

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      ANO = ZERO

      b = 0; n = 0

      do a = 1,group.dim

         aa    = group(a)
         n_bf  = .atom(aa).n_bf
         n_occ = .atom(aa).no_of_occupied_NOs(tol=eps)

         ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(aa).natural_orbitals.restricted(:,1:n_occ)

         b = b + n_bf
         n = n + n_occ

      end

   end

   make_shared_operator(R) ::: private
   ! constructs the roby_shared_operator R_AB = P_A + P_B - P_AB
   ! if spin_case is supplied then either the alpha or beta
   ! operator is constructed, depending on the value of spin_case
      self :: IN
      R :: MAT{REAL}, OUT

   ENSURE(.atom_a.created,"No roby atom A")
   ENSURE(.atom_b.created,"No roby atom B")
   ENSURE(.atom_ab.created,"No roby atom AB")

      P_A,P_B,P_AB :: MAT{REAL}*
      n_a, n_b, n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
      P_AB.create(n_ab,n_ab)

      .make_projection_matrix(P_A ,.atom_a)
      .make_projection_matrix(P_B ,.atom_b)
      .make_projection_matrix(P_AB,.atom_ab)

      R = ZERO
      R(    1:n_a ,     1:n_a ) =  P_A
      R(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      R = R - P_AB

      P_AB.destroy
      P_B.destroy
      P_A.destroy

   end

   make_ionic_operator(I) ::: private
   ! constructs the roby/gould ionic operator I_AB = P_A - P_B
       self :: IN
       I :: MAT{REAL}, OUT

   ENSURE(.atom_a.created,"No roby atom A")
   ENSURE(.atom_b.created,"No roby atom B")
   ENSURE(.atom_ab.created,"No roby atom AB")

      P_B,P_A :: MAT{REAL}*
      n_a, n_b, n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)

      .make_projection_matrix(P_A,.atom_a)
      .make_projection_matrix(P_B,.atom_b)

      I = ZERO
      I(    1:n_a ,     1:n_a ) =  P_A
      I(n_a+1:n_ab, n_a+1:n_ab) = -P_B

      P_B.destroy
      P_A.destroy

   end

   diagonalize_V_AB_operator(X,eigenvectors,eigenvalues) ::: private
   ! For a given operator "X" (for example, C = cos theta or S= sin theta)
   ! in the concatenated AO basis of the atoms in .roby.atom_group,
   !    X = \sum_{i,j} |i> X_{ij} <j|, |i>,|j> in V_{AB},
   ! diagonalise and return the "eigenvectors" and "eigenvalues".
      self :: IN
      X :: MAT{REAL}, IN
      eigenvectors :: MAT{REAL}, OUT
      eigenvalues :: VEC{REAL}, OUT

   ENSURE(.atom_a.created,"No roby atom A")
   ENSURE(.atom_b.created,"No roby atom B")
   ENSURE(.atom_ab.created,"No roby atom AB")

      XX,XV, SS,SI,SH :: MAT{REAL}*
      n_ab :: INT

      n_ab = .n_bf_ab

      XX.create(n_ab,n_ab); XV.create(n_ab,n_ab)
      SS.create(n_ab,n_ab); SI.create(n_ab,n_ab); SH.create(n_ab,n_ab)

      .make_overlap_matrix(SS,.atom_ab,.atom_ab)
      SH.to_sqrt_of(SS)
      SI.to_inverse_of(SH)

      X.back_transform_to(XX,SH)
      XX.solve_symmetric_eigenproblem(eigenvalues,XV)
      eigenvectors.to_product_of(SI,XV)

      SH.destroy; SI.destroy; SS.destroy
      XV.destroy; XX.destroy

   end

! ===========================
! Make roby projected density
! ===========================

!   make_projected_density(rho,density,ANO) ::: private
!   ! Make the Roby-projected density matrix in the concatenated basis
!   ! of AO functions of the atoms in .atom_ab and copy it into "rho",
!   ! a .n_bf x .n_bf matrix where all other matrix elements not corresponding
!   ! to basis functions in .atom_ab are made zero. If present, "density" is
!   ! used instead of the restricted density matrix. If present, "ANO" are used
!   ! for the Roby projection.
!      rho,density :: MAT{REAL}
!      ANO :: MAT{REAL}, optional
!   ENSURE(rho.dim1==.n_bf,"rho has wrong shape")
!   ENSURE(rho.is_square,"rho has wrong shape")
!   ENSURE(density.dim1==.n_bf,"wrong shape, density")
!   ENSURE(density.is_square,"wrong shape, density")
!   ENSURE(.atom_ab.associated,"No atom AB group")
!      D,P,rho_P :: MAT{REAL}*
!      n_bf :: INT
!      n_bf = .n_bf_ab
!      D.create(n_bf,n_bf)
!      .overlap_transform(density,D,col_atom=.atom_ab)
!      P.create(n_bf,n_bf)
!      .make_projection_matrix(P,.atom_ab,ANO)
!      rho_P.create(n_bf,n_bf)
!      D.change_basis_to(rho_P,P) ! rho_P(small) = P_W(small) D(small) P_W(small)
!      .AO_subspace_set(rho,rho_P,A_row_atom=.atom_ab,A_col_atom=.atom_ab)
!      rho_P.destroy
!      P.destroy
!      D.destroy
!   end

! ===============================================
! Low level Roby routines used all over the place
! ===============================================

   expectation(X,group,rho) result (res) ::: private
   ! Get the expectation value of the operator matrix "X" over a certain
   ! "group" of atoms, i.e:
   !    res = Trace ( S(:,group) X S(group,:) rho )
   ! Note that "group" are the indices of the atoms whose basis functions
   ! are used to define the matrix "X".
      self :: IN
      X :: MAT{REAL}, IN
      group :: VEC{INT}, IN
      rho :: OPMATRIX*, optional, IN
      res :: REAL

   ENSURE(X.dim1==.n_bf(group),"wrong X dimension")
   ENSURE(X.is_square,"X is not square")

      density :: OPMATRIX*
      W :: MAT{REAL}*
      n_bf :: INT

      density => .rho
      if (present(rho)) density => rho

      n_bf = .n_bf

      W.create(n_bf,n_bf)

      .overlap_transform(X,W,group)

      if (.spin_multiplicity/=1) then
         res = density.alpha.trace_product_with(W) &
             + density.beta.trace_product_with(W)
      else
         res = density.restricted.trace_product_with(W)
      end

      W.destroy

   end

!   project(X,P,Y,row_atom,col_atom) ::: private
!   ! Do: Y = P^T S(col_atom,row_atom) X S(row_atom,col_atom) P
!   ! where S(col_atom,row_atom) is the AO subspace section of the full
!   ! overlap matrix specified by the basis functions on the atom indices
!   ! in "row_atom" and "col_atom", and "P" is a matrix
!      X,P,Y :: MAT{REAL}
!      row_atom,col_atom :: VEC{INT}
!
!   ENSURE(X.dim1==.n_bf(row_atom),"wrong X dimension")
!   ENSURE(Y.dim1==.n_bf(col_atom),"wrong Y dimension")
!   ENSURE(Y.dim1==P.dim1,"wrong P dimension")
!   ENSURE(X.is_square,"X is not square")
!   ENSURE(Y.is_square,"Y is not square")
!   ENSURE(P.is_square,"P is not square")
!
!      W :: MAT{REAL}*
!
!      W.create(Y.dim1,Y.dim2)
!      .overlap_transform(X,W,row_atom,col_atom)
!      W.change_basis_to(Y,P)
!      W.destroy
!
!   end

   overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom indices
   ! in "row_atom" and "col_atom".
      self :: IN
      X :: MAT{REAL}, IN
      Y :: MAT{REAL}, OUT
      row_atom, col_atom :: VEC{INT}, optional, IN

      SS :: MAT{REAL}*
      n_row,n_col :: INT

      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)

      SS.create(n_row,n_col)

      .make_overlap_matrix(SS,row_atom,col_atom)

      X.change_basis_to(Y,SS)

      SS.destroy

   end

   right_overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = X S(row_atom,col_atom), where S(row_atom,col_atom) is the
   ! AO subspace section of the full overlap matrix specified by the
   ! basis functions on the atom indices in "row_atom" and "col_atom".
      X,Y :: MAT{REAL}
      row_atom, col_atom :: VEC{INT}, optional
      SS :: MAT{REAL}*
      n_row,n_col :: INT
      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)
      SS.create(n_row,n_col)
      .make_overlap_matrix(SS,row_atom,col_atom)
      Y.to_product_of(X,SS)
      SS.destroy
   end

   make_overlap_matrix(SS,row_atom,col_atom) ::: private, PURE
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      self :: IN
      SS :: MAT{REAL}, OUT
      row_atom,col_atom :: VEC{INT}, optional, IN

   ENSURE(.overlap_matrix.associated,"no overlap matrix")
   ENSURE(SS.dim1==.n_bf(row_atom),"wrong shape, SS")
   ENSURE(SS.dim2==.n_bf(col_atom),"wrong shape, SS")

      .AO_subspace_set(SS,.overlap_matrix,B_row_atom=row_atom,B_col_atom=col_atom)

   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom) ::: private, PURE
   ! If either "B_row_atom" or "B_col_atom" is present, then set "A" equal to
   ! the AO subspace blocks of "B" specified by the atom indices in "B_row_atom"
   ! and "B_col_atom". If either is missing, then copy the entire row or col, i.e.
   !    A(small) = B(B_row_atom,B_col_atom)
   ! If either "A_row_atom" or "A_col_atom" is present, then set the AO
   ! subspace blocks of "A" specified by the atom indices in "A_row_atom" and
   ! "A_col_atom" equal to "B". If either is missing then copy the entire row or
   ! column. Uncopied blocks are set to zero, i.e.
   !    A(A_row_atom,A_col_atom) = B(small)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      A_row_atom,A_col_atom :: VEC{INT}, optional, IN
      B_row_atom,B_col_atom :: VEC{INT}, optional, IN

      n_row_atoms,n_col_atoms :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      first_basis_fn_for,last_basis_fn_for :: VEC{INT}*
      Achk,Bchk :: BIN

    Achk = present(A_row_atom) OR present(A_col_atom) 
    Bchk = present(B_row_atom) OR present(B_col_atom)
    ENSURE(Achk NEQV Bchk,"missing A/B row or col atoms")

      .atom.make_atom_basis_fn_limits(first_basis_fn_for,last_basis_fn_for)

      if (present(B_row_atom) OR present(B_col_atom)) then

         ENSURE(B.dim1==.n_bf,"B has wrong shape")
         ENSURE(B.dim2==.n_bf,"B has wrong shape")

         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.atom(B_row_atom).n_bf,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).n_bf,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i))
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).n_bf
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(B_col_atom(j))
                  l_j = last_basis_fn_for( B_col_atom(j))
                  n_j = .atom(B_col_atom(j)).n_bf
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(B_row_atom)) then

            n_row_atoms = size(B_row_atom)
            ENSURE(A.dim1==.atom(B_row_atom).n_bf,"A has wrong shape")
            ENSURE(A.dim2==.n_bf,"A has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i));
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).n_bf
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end

         else if (present(B_col_atom)) then

            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.n_bf,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).n_bf,"A has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(B_col_atom(j));
               l_j = last_basis_fn_for( B_col_atom(j))
               n_j = .atom(B_col_atom(j)).n_bf
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end

         end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then

         ENSURE(A.dim1==.n_bf,"A has wrong shape")
         ENSURE(A.dim2==.n_bf,"A has wrong shape")

         A = ZERO

         if (present(A_row_atom) AND present(A_col_atom)) then

            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_row_atom).n_bf,"B has wrong shape")
            ENSURE(B.dim2==.atom(A_col_atom).n_bf,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i))
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).n_bf
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(A_col_atom(j))
                  l_j = last_basis_fn_for( A_col_atom(j))
                  n_j = .atom(A_col_atom(j)).n_bf
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(A_row_atom)) then

            n_row_atoms = size(A_row_atom)
            ENSURE(B.dim1==.atom(A_row_atom).n_bf,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i));
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).n_bf
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end

         else if (present(A_col_atom)) then

            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_col_atom).n_bf,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(A_col_atom(j));
               l_j = last_basis_fn_for( A_col_atom(j))
               n_j = .atom(A_col_atom(j)).n_bf
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end

         end

      end

      ! Clean
      last_basis_fn_for.destroy
      first_basis_fn_for.destroy

   end

! ==============
! Output methods
! ==============

   put_all_info
   ! Put to stdout the results of a complete bond analysis
      self :: IN

      .put_basics
      .put_populations
      .put_bond_indices
    ! .put_charges
    ! .put_dipole_moments

   end

   put_basics
   ! Put to stdout the Roby atom data
      self :: IN

   ENSURE(.atom.associated,"no atom data")

      i :: INT
      symbol :: VEC{STR}*

      stdout.flush
      stdout.text("==============================")
      stdout.text("Roby-Gould population analysis")
      stdout.text("==============================")
      stdout.flush
      stdout.show("Molecule charge         =",.charge)
      stdout.show("Molecule multiplicity   =",.spin_multiplicity)
      stdout.flush
      stdout.show("Kind of calculation     =",.roby_kind)
      stdout.show("Homoleptic calculation? =",.is_homoleptic)
      stdout.show("Occupied ANO cutoff     =",.occupied_ANO_cutoff)
      stdout.show("Output theta info?      =",.output_theta_info)
      stdout.flush

      if (.is_homoleptic) then
      symbol => .unique_tags
      do i = 1,.n_group
      stdout.show("Atom group "//i.to_str.trim//"            =",symbol(i))
      end
      end

      if (.atom_list.associated) then
      symbol => .atom(.atom_list).unique_tags
      stdout.show("Atom list               =",symbol)
      stdout.show("No. of atoms            =",symbol.dim)
      symbol.destroy
      stdout.show("Analyze all atom pairs? =",.analyze_all_atom_pairs)
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      end

      symbol.destroy

      stdout.flush
      stdout.text("Angle cutoff's in degrees")
      stdout.flush
      stdout.show("Covalent index cutoff   =",.covalent_cutoff.to_units("degree"))
      stdout.show("Ionic bond index cutoff =",.ionic_cutoff.to_units("degree"))
      stdout.show("Zero angle cutoff       =",.zero_cutoff.to_units("degree"))
      stdout.show("Pi/2 cutoff             =",.pi_on_2_cutoff.to_units("degree"))

   end

   put_populations
   ! Put to stdout the only Roby atom populations
      self :: IN

   ENSURE(.n1.associated,"no atom populations exist")
   ENSURE(.atom.associated,"no atom data")

      table :: VEC{TABLE_COLUMN}@
      symbols :: VEC{STR}*
      labels :: VEC{INT}*
      f :: INT


      stdout.flush
      stdout.text("=====================")
      stdout.text("Roby atom populations")
      stdout.text("=====================")
      stdout.flush

      ! Create table
      table.create(2)

      ! Set the table headings
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      if (.is_homoleptic) then
         symbols.create(.n_group)
         labels.create(.n_group)
         f = 1
         labels = f.sequence_up_to(.n_group)
         symbols = labels.to_str
         labels.destroy
      else
         symbols => .unique_tags
      end
      table(1).set_values(symbols)

      table(2).set_heading(" No. of")
      table(2).set_subhead("electrons")
      table(2).set_values(.n1)

      ! Put table
      table.put(label_rows=FALSE)

      ! Clean
      symbols.destroy
      table.destroy

   end

   put_bond_indices
   ! Put to stdout the Roby bond indices, including the shared populations
      self :: IN

      if (.is_homoleptic) then
         .put_bond_indices_group
      else
         .put_bond_indices_atoms
         .put_bond_indices_short
      end

   end

   put_bond_indices_group
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_homoleptic,"job is not homoleptic")
   ENSURE(.n_group>1,"must be at leat two groups")

      table :: VEC{TABLE_COLUMN}@
      symbol :: VEC{STR}*
      g_A,g_B :: VEC{INT}*
      n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      n_group, n_pair,i,a,b :: INT

      n_group = .n_group

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      stdout.flush
      stdout.text("Bond indices appear only between atom groups.")
      stdout.flush
      symbol => .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(10)

      ! Set the table headings
      table( 1).set_heading("Grp")
      table( 1).set_subhead("  A")
      table( 2).set_heading("Grp")
      table( 2).set_subhead("  B")
      table( 3).set_heading("n_A")
      table( 3).set_width_from(TEN)
      table( 4).set_heading("n_B")
      table( 4).set_width_from(TEN)
      table( 5).set_heading("n_AB")
      table( 5).set_width_from(TEN)
      table( 6).set_heading("s_AB")
      table( 6).set_width_from(TEN)
      table( 7).set_heading(" Cov.")
      table( 7).set_subhead("index")
      table( 7).set_width_from(-TEN)
      table( 8).set_heading("Ionic")
      table( 8).set_subhead("index")
      table( 8).set_width_from(-TEN)
      table( 9).set_heading(" Bond")
      table( 9).set_subhead("index")
      table( 9).set_width_from(ONE)
      table(10).set_heading("% Cov")
      table(10).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      n_pair = n_group - 1
      n_pair = n_pair.triangle_number
      g_A.create(n_pair)
      g_B.create(n_pair)
      n_A.create(n_pair)
      n_B.create(n_pair)
      nAB.create(n_pair)
      sAB.create(n_pair)
      cAB.create(n_pair)
      iAB.create(n_pair)
      tAB.create(n_pair)
      pAB.create(n_pair)

      i = 0
      do a = 1,.n_group
      do b = 1,a-1
         i = i + 1
         g_A(i) = a
         g_B(i) = b
         n_A(i) = .n1(a)
         n_B(i) = .n1(b)
         nAB(i) = .n2(a,b)
         sAB(i) = .n1(a) + .n1(b) - .n2(a,b)
         cAB(i) =  .cov_index(a,b)
         iAB(i) =  .ion_index(a,b)
         tAB(i) = .bond_index(a,b)
         pAB(i) = .percent_covalency(a,b)
      end
      end

      ! Set table data
      table( 1).set_values(g_A)
      table( 2).set_values(g_B)
      table( 3).set_values(n_A)
      table( 4).set_values(n_B)
      table( 5).set_values(nAB)
      table( 6).set_values(sAB)
      table( 7).set_values(cAB)
      table( 8).set_values(iAB)
      table( 9).set_values(tAB)
      table(10).set_values(pAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Clean
      table.clear_columns

      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      sAB.destroy
      nAB.destroy
      n_B.destroy
      n_A.destroy

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy

   end

   put_bond_indices_atoms
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{VEC_{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      stdout.flush
      if (.analyze_all_atom_pairs) then
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading("R(A--B)")
      table( 7).set_subheading("/Angs.")
      table( 7).set_width_from(ONE)

      table( 8).set_heading("n_A")
      table( 8).set_width_from(TEN)
      table( 9).set_heading("n_B")
      table( 9).set_width_from(TEN)
      table(10).set_heading("n_AB")
      table(10).set_width_from(TEN)
      table(11).set_heading("s_AB")
      table(11).set_width_from(TEN)
      table(12).set_heading(" Cov.")
      table(12).set_subhead("index")
      table(12).set_width_from(-TEN)
      table(13).set_heading("Ionic")
      table(13).set_subhead("index")
      table(13).set_width_from(-TEN)
      table(14).set_heading(" Bond")
      table(14).set_subhead("index")
      table(14).set_width_from(ONE)
      table(15).set_heading("% Cov")
      table(15).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         n_A.create(n_bonds)
         n_B.create(n_bonds)
         nAB.create(n_bonds)
         sAB.create(n_bonds)
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         n_A = .n1(pair(:,1))
         n_B = .n1(pair(:,2))
         forall (i=1:n_bonds)
         nAB(i) = .n2(pair(i,1),pair(i,2))
         sAB(i) = n_A(i) + n_B(i) - nAB(i)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(n_A)
         table( 9).set_values(n_B)
         table(10).set_values(nAB)
         table(11).set_values(sAB)
         table(12).set_values(cAB)
         table(13).set_values(iAB)
         table(14).set_values(tAB)
         table(15).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         sAB.destroy
         nAB.destroy
         n_B.destroy
         n_A.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_bond_indices_short
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{VEC_{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      ind :: VEC{INT}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      stdout.flush
      stdout.text("==============================")
      stdout.text("Sorted Roby-Gould bond indices")
      stdout.text("==============================")
      stdout.flush
      stdout.text(". Indices are sorted from lowest to highest")
      stdout.flush
      if (.analyze_all_atom_pairs) then
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD)")
      stdout.text("  AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom(:).tag)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("R(A--B)")
      table(4).set_subheading("/Angs.")
      table(4).set_width_from(ONE)

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_width_from(-TEN)
      table(6).set_heading("Ionic")
      table(6).set_subhead("index")
      table(6).set_width_from(-TEN)
      table(7).set_heading(" Bond")
      table(7).set_subhead("index")
      table(7).set_width_from(ONE)
      table(8).set_heading("% Cov")
      table(8).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Sort & rearrange
         ind.create(n_bonds)
         tAB.quick_sort(ind,decreasing_order=TRUE)
         labels(:,1) = labels(ind,1)
         labels(:,2) = labels(ind,2)
         dist = dist(ind)
         cAB  = cAB(ind)
         iAB  = iAB(ind)
         tAB  = tAB(ind)
         pAB  = pAB(ind)

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dist)
         table(5).set_values(cAB)
         table(6).set_values(iAB)
         table(7).set_values(tAB)
         table(8).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         ind.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_charges
   ! Put to stdout the group charges.
      self :: IN

   ENSURE(.gould_charge.associated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.associated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.created,"no atom group data")

      a :: INT
      homoleptic :: BIN
      symb :: STR
      symbol :: VEC{STR}*

      homoleptic = .is_homoleptic
      if (NOT homoleptic) symbol => .unique_tags

      stdout.flush
      stdout.text("Group charges:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Roby-Gould")
      stdout.put("Cruickshank")
      stdout.put("Sum_b  Sab/2")
      stdout.put("Sum_bc Sabc/3")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_group
         if (homoleptic) then; symb = a.to_str
         else                ; symb = symbol(a)
         end
         stdout.put(symb,int_width=TRUE)
         stdout.put(.gould_charge(a))
         stdout.put(.cruickshank_charge(a))
         stdout.put(.summed_n2(a)/TWO)
         stdout.put(.summed_n3(a)/THREE)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=4)

      if (NOT homoleptic) symbol.destroy

   end

   put_dipole_moments
   ! Dipole moments are calculated from the charges
      self :: IN

   ENSURE(.gould_charge.associated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.associated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")

      a :: INT
      gd,cd :: VEC{REAL}(3)

      gd = ZERO
      cd = ZERO

      do a = 1,.n_group
         gd(:) = gd(:) + .gould_charge(a)*.atom(a).position(:)
         cd(:) = cd(:) + .cruickshank_charge(a)*.atom(a).position(:)
      end

      ! Convert from AU to Debyes
      gd = gd * ("debye").conversion_factor
      cd = cd * ("debye").conversion_factor

      stdout.flush
      stdout.text("Dipole moments (in DEBYE):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Charge type")
      stdout.put("X")
      stdout.put("Y")
      stdout.put("Z")
      stdout.put("Magnitude")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Roby-Gould")
      stdout.put(gd(1))
      stdout.put(gd(2))
      stdout.put(gd(3))
      stdout.put(sqrt(gd(1)**2 + gd(2)**2 + gd(3)**2))
      stdout.flush
      stdout.put("Cruickshank")
      stdout.put(cd(1))
      stdout.put(cd(2))
      stdout.put(cd(3))
      stdout.put(sqrt(cd(1)**2 + cd(2)**2 + cd(3)**2))
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)

   end

   put_unique_tags(group,name)
   ! Output atom labels for the atom indices given in "group"
      self :: IN
      group :: VEC{INT}, IN
      name :: STR, optional, IN

      symbol :: STR
      label :: STR
      g :: INT

      label = " "
      if (present(name)) label = name

      stdout.put("Atom "//trim(label)//" =")
      do g = 1,group.dim
         symbol = .atom(group(g)).tag
         stdout.put(trim(symbol),width=len_trim(symbol)+1)
      end
      stdout.flush

   end

   put_theta_info
   ! Output Theta-space information
      self :: IN

   ENSURE(.atom_a.created, "No Roby atom A data")
   ENSURE(.atom_b.created, "No Roby atom B data")
   ENSURE(.atom_ab.created,"No Roby atom AB data")

      n,i,j,angle :: INT
      evn,par,ang :: VEC{INT}*
      cst,snt :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("============================")
      stdout.text("Roby-Gould angle eigenspaces")
      stdout.text("============================")
      stdout.flush
      stdout.text(". Analysis is for:")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(B)")
      stdout.flush
      stdout.text(". Angles are given to the nearest degree")
      stdout.text(". 90-degree angle spaces are not shown")
      stdout.text(". States come in bonding-antibonding pairs")
      stdout.flush

      ! Columns
      n = .n_theta_angles
      evn.create(n)
      par.create(n)
      ang.create(n)
      cst.create(n)
      snt.create(n)

      ! Set column data
      j = 0
      do i = 1,.n_bf_ab
         angle = nint(.theta_angle(i))
         if (angle==90) cycle
         j = j + 1
         evn(j) = i
         par(j) = .pair(j)
         ang(j) = angle
         cst(j) = .eval_C(i)
         snt(j) = .eval_I(i)
      end

      ! Do table
      table.create(5)

      table(1).set_heading("Eigvec")
      table(1).set_subhead("   #  ")
      table(1).set_values(evn)

      table(2).set_heading("Paired")
      table(2).set_subhead("  with")
      table(2).set_values(par)

      table(3).set_heading("theta")
      table(3).set_subhead(" /deg")
      table(3).set_values(ang)

      table(4).set_heading("  cos")
      table(4).set_subhead("theta")
      table(4).set_values(cst)

      table(5).set_heading("  sin")
      table(5).set_subhead("theta")
      table(5).set_values(snt)

      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      snt.destroy
      cst.destroy
      ang.destroy
      par.destroy
      evn.destroy

   end

   put_theta_bond_info
   ! Output Theta-space bond information
      self :: IN

      n,i,j,angle :: INT
      par :: VEC{STR}*
      ang :: VEC{INT}*
      c_p,c_m,cov,i_p,i_m,ion :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}@

      ! Columns
      n = .n_paired_angles

      par.create(n)
      ang.create(n)
      c_p.create(n)
      c_m.create(n)
      cov.create(n)
      i_p.create(n)
      i_m.create(n)
      ion.create(n)

      ! Set table column data
      j = 0
      do i = 1,.n_bf_ab

         if (.pair(i)<1 OR i<.pair(i)) cycle

         angle = nint(.theta_angle(i))
         if (angle==90) cycle

         j = j + 1

         par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
         ang(j) = angle
         c_p(j) = .pop_C(i)
         c_m(j) = .pop_C(.pair(i))
         cov(j) = .covalent_index(i)
         i_p(j) = .pop_I(i)
         i_m(j) = .pop_I(.pair(i))
         ion(j) = .ionic_index(i)

      end

      ! Do table
      table.create(8)

      table(1).set_heading("Paired")
      table(1).set_subhead(" space")
      table(1).set_values(par)

      table(2).set_heading("theta")
      table(2).set_subhead(" /deg")
      table(2).set_values(ang)

      table(3).set_heading(" C+")
      table(3).set_subhead("pop")
      table(3).set_values(c_p)

      table(4).set_heading(" C-")
      table(4).set_subhead("pop")
      table(4).set_values(c_m)

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_values(cov)

      table(6).set_heading(" I+")
      table(6).set_subhead("pop")
      table(6).set_values(i_p)

      table(7).set_heading(" C-")
      table(7).set_subhead("pop")
      table(7).set_values(i_m)

      table(8).set_heading(" Ion.")
      table(8).set_subhead("index")
      table(8).set_values(ion)

      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      ion.destroy
      i_m.destroy
      i_p.destroy
      cov.destroy
      c_m.destroy
      c_p.destroy
      ang.destroy
      par.destroy

   end

   put_theta_atom_pops
   ! Output Roby angles and populations
      self :: IN

   ENSURE(.atom_a.created, "No Roby atom A data")
   ENSURE(.atom_b.created, "No Roby atom B data")
   ENSURE(.atom_ab.created,"No Roby atom AB data")
   ENSURE(.theta_angle.associated, "No theta angles")

      n,i,j,angle :: INT
      evn,ang :: VEC{INT}*
      n_A,n_B,nAB :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("======================================")
      stdout.text("Roby-Gould pair-atom angle eigenspaces")
      stdout.text("======================================")
      stdout.flush
      stdout.text(". Analysis is for:")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(B)")
      stdout.flush
      stdout.text(". Angles given to the nearest degree")
      stdout.text(". 90-degree angle spaces are not shown")

      ! Columns
      n = .n_theta_angles

      evn.create(n)
      ang.create(n)
      n_A.create(n)
      n_B.create(n)
      nAB.create(n)

      ! Set column data
      j = 0
      do i = 1,.n_bf_ab
         angle = nint(.theta_angle(i))
         if (angle==90) cycle
         j = j + 1
         evn(j) = i
         ang(j) = angle
         n_A(j) = .pop_A(i)
         n_B(j) = .pop_B(i)
         nAB(j) = .pop_A(i) + .pop_B(i)
      end

      ! Do table
      table.create(5)

      table(1).set_heading("Eigvec")
      table(1).set_subhead("   #  ")
      table(1).set_values(evn)

      table(2).set_heading(" Theta")
      table(2).set_subhead("  /deg")
      table(2).set_values(ang)

      table(3).set_heading("n_A")
      table(3).set_values(n_A)

      table(4).set_heading("n_B")
      table(4).set_values(n_B)

      table(5).set_heading("Total")
      table(5).set_values(nAB)

      table.put

      ! Clean
      table.destroy
      nAB.destroy
      n_B.destroy
      n_A.destroy
      ang.destroy
      evn.destroy

   end

   n_theta_angles result (res) ::: PURE
   ! Output Roby angles and populations
      self :: IN
      res :: INT

   ENSURE(.theta_angle.associated, "No theta angles")

      i,angle :: INT

      res = 0

      do i = 1,.n_bf_ab
         angle = nint(.theta_angle(i))
         if (angle==90) cycle
         res = res + 1
      end

   end

   n_paired_angles result (res) ::: PURE
   ! Output Roby angles and populations
      self :: IN
      res :: INT

   ENSURE(.pair.associated, "No pair info")
   ENSURE(.theta_angle.associated, "No theta angles")

      i,angle :: INT

      res = 0

      do i = 1,.n_bf_ab

         if (.pair(i)<1 OR i<.pair(i)) cycle

         angle = nint(.theta_angle(i))
         if (angle==90) cycle

         res = res + 1

      end

   end

   put_shared_population
   ! Put to stdout the multiple shared Roby atom populations
      self :: IN

   ENSURE(.subgroup_pop.associated,"no subgroup population totals exist")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.created,"no atom group data")

      a :: INT
      symbol :: VEC{STR}*

      stdout.flush
      stdout.text("===============================")
      stdout.text("Roby multiple shared population")
      stdout.text("===============================")
      stdout.flush
      stdout.show("Multiple shared population =",.n_shared)
      stdout.text("Contributions by subgroup size:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Subgrp size",int_width=TRUE)
      stdout.put("Subgrp Pop.")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      do a = 1,.n_group
         stdout.put(symbol(a),int_width=TRUE)
         stdout.put(.subgroup_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=1)

      symbol.destroy

   end

end
