!---------------------------------------------------------------------------
!
! OBJECT: Generic object operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: object.foo 4349 2014-05-06 02:01:54Z dylan_ $
!---------------------------------------------------------------------------

virtual module OBJECT

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!  =================
!  Memory allocation
!  =================

   create ::: leaky, PURE
   ! Allocate an object
      self :: allocatable, INOUT

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

#ifdef USE_PRECONDITIONS
      allocate(self,stat=status)
      ENSURE(status==0,"error in allocating memory")
#else
      allocate(self)
#endif

   end

   create ::: leaky, PURE
   ! Allocate an object and set defaults
      self :: allocatable, INOUT

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

#ifdef USE_PRECONDITIONS
      allocate(self,stat=status)
      ENSURE(status==0,"error in allocating memory")
#else
      allocate(self)
#endif

      .set_defaults

   end

   destroy ::: leaky, PURE
   ! Deallocate "self"
      self :: allocatable, INOUT

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

      if (NOT allocated(self)) return

#ifdef USE_PRECONDITIONS
      deallocate(self,stat=status)
      ENSURE(status==0,"error in deallocating memory")
#else
      deallocate(self)
#endif

   end

   created result (res) ::: pure
   ! Returns true if self has been allocated
      self :: allocatable, IN
      res :: BIN

      res = allocated(self)

   end

   destroyed result (res) ::: pure
   ! Returns true if self has *not* been allocated
      self :: allocatable, IN
      res :: BIN

      res = NOT allocated(self)

   end

!  ==========
!  Saved self
!  ==========

   set_saved_self 
   ! Set saved_self
      self :: allocatable, INOUT
      saved_self => self
   end

   set_saved_self 
   ! Set saved_self. This version has self a target.
      self :: target
      saved_self => self
   end

   set_from_saved_self
   ! Set from saved_self
      self :: allocatable, INOUT
      self => saved_self
   end

!  ============
!  Set routines
!  ============

   set(object) ::: pure
   ! Set the object.
      self   :: OUT
      object :: OBJECT, IN

      self = object

   end

   set(object) ::: pure
   ! Set the object. Pointer parts are assigned not copied.
      self   :: OUT
      object :: OBJECT, IN

      self = object

   end

   set(val) ::: pure
   ! Generic set
      self :: INOUT
      val  :: VAL?, IN

      ARG? = val

   end

!  ============
!  I/O routines
!  ============

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.

   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")

      word :: STR

      ! Read the open braces {
      stdin.read(word)

      ! Echo keyword if requested
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over input keywords

         ! Read the keyword
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case

         ! Append any lonely = sign
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then 
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end

         ! Echo keyword if requested
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end

         ! Exit if keyword is closing brace }
         if (word=="}")      exit

         ! Process the keyword 
         .:process_keyword(word)

      end

   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: allocatable, INOUT

   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")

      word :: STR

      ! Read the open braces {
      stdin.read(word)


      ! Echo keyword if requested
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over input keywords

         ! Read the keyword
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case

         ! Append any lonely = sign
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then ! assume this is an attached = sign
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end

         ! Echo keyword if requested
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end

         ! Exit if keyword is closing brace }
         if (word=="}")      exit

         ! Process the keyword 
         .:process_keyword(word)

      end

   end

   read_units
   ! Read a string which describes the units to be used

      if (FALSE) self = self

      stdin.set_default_units(stdin.next_str)

   end

   read_junk
   ! Read in a junk string, useful for ignoring a field

      if (FALSE) self = self

      stdin.skip_next_item

   end

   read_and_set
   ! Generic read and set
      val :: VAL?

      stdin.read(val)

      SET?(val)

   end

   read_and_set
   ! Generic read and set a quantity with units
      val :: VAL?

      stdin.read_quantity(val)

      SET?(val)

   end

!  ==========================
!  Input key related routines
!  ==========================

   read_keys ::: leaky
   ! Read the "keys" module variable.
      self :: allocatable, IN

      ! Bind routine
      if (.created) then
      end

      keys.destroy
      stdin.read_ptr(keys)

   end

   process_keys ::: leaky
   ! Process each keyword in the "keys" module variable.
      self :: INOUT

   ENSURE(keys.created,"no keys")

      k,l,n_key :: INT
      keyword :: STR
      keyword_echo :: BIN

      ! The number of keys
      n_key = keys.dim

      ! Keyword counter
      k = 0

      do ! Loop over keywords in "keys"

         ! Get the next keyword
         k = k + 1
         keyword = keys(k)

         ! Exit if close brace
         if (keyword=="}") exit

         if (keyword=="{") then ! embedded keyword

            ! Turn off keyword echo
            keyword_echo = tonto.keyword_echo
            tonto.keyword_echo = FALSE

            ! Find closing brace of embedded section
            l = keys(k:).index_of_matching_bracket("{")
            DIE_IF(l==0,"no matching closing brace in embedded keyword")

            ! Set internal array

            ! Process internalized keywords
            stdin.redirect(keys(k:k+l-1))
            .:read_keywords
            stdin.revert

            ! Reset key counter
            k = k + l - 1

            ! Reset keyword echo
            tonto.keyword_echo = keyword_echo

         else ! plain-old keyword

            ! Process plain-old keyword
            .:process_keyword(keyword)

         end

         ! Exit if no keys left
         if (k==n_key) exit

      end

   end

   set_keys(the_keys) ::: leaky
   ! Set the "keys" module variable.
      self :: allocatable, IN
      the_keys :: VEC{STR}, IN

      ! Bind the routine
      if (.created) then
      end

      keys = the_keys

   end

!  ======
!  Output
!  ======

   dump(object_name,ptr) 
   ! Dump object data as text
      object_name :: STR
      ptr :: BIN, optional

      is_ptr :: BIN

      is_ptr = FALSE
      if (present(ptr)) is_ptr = ptr

      stdout.flush

      if (is_ptr) then; stdout.text(trim(object_name)//":TYPE@ = { ")
      else;             stdout.text(trim(object_name)//":TYPE = { ")
      end

      stdout.increment_margin_width(1)

      .do_dump

      stdout.increment_margin_width(-1)
      stdout.flush

      stdout.text("}")

   end

   dmpp(object_name)
   ! Dump pointer object data as text
      self :: allocatable, INOUT
      object_name :: STR, IN

      if (.destroyed) then

         stdout.flush
         stdout.text(trim(object_name)//":TYPE* = null")

      else

         .dump(trim(object_name),ptr=TRUE)

      end

   end

   dmpp(object_name)
   ! Dump an allocatable object data as text
      self :: allocatable, IN
      object_name :: STR, IN

      if (.destroyed) then

         stdout.flush
         stdout.text(trim(object_name)//":TYPE* = null")

      else

         .dump(trim(object_name),ptr=TRUE)

      end

   end

end
