module BREAKDOWN_DATA
   implicit none

   num_interaction_directions :: INT = 4 
   num_interaction_types :: INT = 5 
   column_heading :: VEC{STR}(4) = ["group1-group2", "group1-bulk  ", "bulk-group2  ", "bulk-bulk    "]
   row_heading :: VEC{STR}(5) = ["electrostatic     ", "polarisation      ", "dispersion        ", "exchange-repulsion", "total             "]
   num_atom_groups :: INT = 2

   contains
   
!  ===================
!  Allocation routines
!  ===================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end
   
   nullify_ptr_part
   ! Nullify the pointer parts of self
   ! Check whether need to nullify references to DM, and molecules
      self :: INOUT

      if (.groups.created) .groups.nullify_ptr_part
      
      nullify(.E_nn)
      nullify(.E_ne)
      nullify(.E_ee)
      nullify(.E_el)
      nullify(.E_pol)
      nullify(.E_disp)
      nullify(.E_ex)
      nullify(.E_rep)
      nullify(.E_er)
      nullify(.E_tot)
      nullify(.ao_2e_ints)
      nullify(.attraction_mx)
      nullify(.groups)
      nullify(.group_pairs)
      nullify(.group_energies)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self

      .groups.nullify_ptr_part
      
      .E_nn.destroy
      .E_ne.destroy
      .E_ee.destroy
      .E_el.destroy
      .E_pol.destroy
      .E_disp.destroy
      .E_ex.destroy
      .E_rep.destroy
      .E_er.destroy
      .E_tot.destroy
      .ao_2e_ints.destroy
      .attraction_mx.destroy
      .groups.destroy
      .group_pairs.destroy
      .group_energies.destroy
   end

   create_copy(breakdown_data) ::: leaky
   ! Create a copy of the "breakdown_data" object
      self :: PTR
      breakdown_data :: BREAKDOWN_DATA
      .create
      .copy(breakdown_data)
   end

   copy(breakdown_data) ::: leaky
   ! Make a copy of the "breakdown_data" object
      breakdown_data :: BREAKDOWN_DATA 

      self = breakdown_data
      .nullify_ptr_part
      .groups.copy(breakdown_data.groups)

      if (breakdown_data.E_nn.created) .E_nn.create_copy(breakdown_data.E_nn)
      if (breakdown_data.E_ne.created) .E_ne.create_copy(breakdown_data.E_ne)
      if (breakdown_data.E_ee.created) .E_ee.create_copy(breakdown_data.E_ee)
      if (breakdown_data.E_pol.created) .E_pol.create_copy(breakdown_data.E_pol)
      if (breakdown_data.E_pol.created) .E_pol.create_copy(breakdown_data.E_pol)
      if (breakdown_data.E_disp.created) .E_disp.create_copy(breakdown_data.E_disp)
      if (breakdown_data.E_ex.created) .E_ex.create_copy(breakdown_data.E_ex)
      if (breakdown_data.E_rep.created) .E_rep.create_copy(breakdown_data.E_rep)
      if (breakdown_data.E_er.created) .E_er.create_copy(breakdown_data.E_er)
      if (breakdown_data.E_tot.created) .E_tot.create_copy(breakdown_data.E_tot)
      if (breakdown_data.ao_2e_ints.created) .ao_2e_ints.create_copy(breakdown_data.ao_2e_ints)
      if (breakdown_data.attraction_mx.created) .attraction_mx.create_copy(breakdown_data.attraction_mx)
      if (breakdown_data.groups.created) .groups.create_copy(breakdown_data.groups)
      if (breakdown_data.group_pairs.created) .group_pairs.create_copy(breakdown_data.group_pairs)
      if (breakdown_data.group_energies.created) .group_energies.create_copy(breakdown_data.group_energies)

      if (breakdown_data.mol1.created) .mol1 => breakdown_data.mol1 
      if (breakdown_data.mol2.created) .mol2 => breakdown_data.mol2 
      if (breakdown_data.density_matrix.created) .density_matrix => breakdown_data.density_matrix 
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default molecule
      .units = "hartrees"
      .conversion_factor = ONE
   end
   
!  ===============
!  General methods 
!  ===============

   put(mol) ::: leaky
      self :: INOUT

      mol :: MOLECULE*

      ENSURE(mol.atom_group.created, "no atom group information")
      ENSURE(mol.atom_group.dim == num_atom_groups, "must have only 2 atom groups")
      BREAKDOWN_DATA:check_molecule(mol.atom_group(1).mol, "1")
      BREAKDOWN_DATA:check_molecule(mol.atom_group(2).mol, "2")

      .mol => mol
      
      .read_keywords
      .get_atom_energy_breakdown
      .get_functional_groups_energy_breakdown
      .put_atomic_energy_breakdown
      .put_functional_group_energy_breakdown
   end

!  =============
!  Input methods 
!  =============

   read_keywords ::: get_from(OBJECT), leaky
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                      ")  ! exit read_loop
         case ("groups=                "); .read_groups
         case ("group_sizes=           "); .read_group_sizes
         case ("num_groups=            "); .read_num_groups
         case ("num_queries=           "); .read_num_group_pairs
         case ("queries=               "); .read_group_pairs
         case ("units=                 "); .read_units
         case default;       UNKNOWN(word)
      end

   end

   read_units ::: leaky
      self :: INOUT

      stdin.read(.units)
      .units.to_lower_case
      if (trim(.units) == "hartree" OR trim(.units) == "hartrees") then
         .conversion_factor = ONE
      else
         .conversion_factor = .units.conversion_factor 
      end
   end
   
   read_num_groups ::: leaky
      self :: INOUT

      num_groups :: INT

      stdin.read(num_groups)
      .groups.create(num_groups)
   end

   read_group_sizes ::: leaky
      self :: INOUT

      ENSURE(.groups.created, "number of groups must be provided before group sizes")

      i :: INT
      group_sizes :: VEC{INT}(.groups.dim)

      stdin.read(group_sizes)

      do i = 1, .groups.dim
         .groups(i).element.create(group_sizes(i))
         .groups(i).element = 0 
      end
   end
  
   read_groups
      self :: INOUT

      ENSURE(.groups.created, "number of groups must be provided before groups")
      ENSURE(.group_sizes_provided, "group sizes must be provided before groups")
     
      i :: INT
      
      do i = 1, .groups.dim
         stdin.read(.groups(i).element)
      end
   end

   read_num_group_pairs ::: leaky
      self :: INOUT

      num_group_pairs :: INT

      stdin.read(num_group_pairs)
      .group_pairs.create(num_group_pairs, num_atom_groups)
      .group_pairs = 0
   end

   read_group_pairs
      self :: INOUT

      ENSURE(.group_pairs.created, "number of queries must be read in before queries")

      stdin.read(.group_pairs)
   end
   
!  ======================
!  Atom-atom calculations 
!  ======================
   
   get_atom_energy_breakdown ::: leaky
      self :: INOUT

      atom_group1, atom_group2 :: ATOM_GROUP*
      
      atom_group1 => .mol.atom_group(1)
      atom_group2 => .mol.atom_group(2)
      .mol1 => atom_group1.mol
      .mol2 => atom_group2.mol
      
      .ao_2e_ints.create(.mol.n_bf, .mol.n_bf, .mol.n_bf, .mol.n_bf)
      .E_tot.create(.mol1.n_atom, .mol2.n_atom)

      .mol.SCF:merge_group_MOs
      .mol.BASE:make_scf_density_matrix
      .density_matrix => .mol.density_matrix.restricted
      .mol.FOCK:make_ERI_integrals(.ao_2e_ints)
      
      .get_electrostatic_exchange_energy_breakdown
      .get_polarisation_energy_breakdown
      .mol1.atom.get_dispersion_energy_breakdown(.mol2.atom, .E_disp)
      .E_tot = .E_el + .E_disp + .E_pol + .E_ex
      .get_exchange_repulsion_energy_breakdown
   end

!Electrostatic and exchange interaction
   get_electrostatic_exchange_energy_breakdown ::: leaky
      self :: INOUT
      
      .E_el.create(.mol1.n_atom, .mol2.n_atom)

      .mol1.atom.get_nn_repulsion_energy_breakdown(.mol2.atom, .E_nn)
      .get_ne_attraction_energy_breakdown
      .get_ee_repulsion_and_exchange_energy_breakdown

      .E_el = .E_nn + .E_ne + .E_ee
   end

   get_ne_attraction_energy_breakdown ::: leaky
      self :: INOUT
      
      i :: INT

      .E_ne.create(.mol1.n_atom, .mol2.n_atom) !Indexing:.molecule1-.molecule2
      .E_ne = ZERO

      .attraction_mx.create(.mol.n_atom, .mol.n_bf, .mol.n_bf)
      .mol.INTS:get_nuclear_attraction_by_nucleus_matrices(.attraction_mx)
      do i = 1, .mol1.n_atom
         .mol2.INTS:get_one_electron_operator_breakdown(.attraction_mx(i, :, :), .E_ne(i, :), .density_matrix, .mol1.n_bf, ONE)
      end
      do i = 1, .mol2.n_atom
         .mol1.INTS:get_one_electron_operator_breakdown(.attraction_mx(i + .mol1.n_atom, :, :), .E_ne(:, i), .density_matrix, 0, ONE)
      end
   end

   get_ee_repulsion_and_exchange_energy_breakdown ::: leaky
      self :: INOUT
      
      .E_ee.create(.mol1.n_atom, .mol2.n_atom)
      .E_ex.create(.mol1.n_atom, .mol2.n_atom)
      .E_ee = ZERO
      .E_ex = ZERO

      .get_ee_repulsion_and_exchange_energy_breakdown_inner(.E_ee, .E_ex, .mol1, .mol2, ONE, .mol1.n_bf)      
   end

!Polarisation interaction
   get_polarisation_energy_breakdown ::: leaky
      self :: INOUT
      
      E_pol_T :: MAT{REAL}*
      i, j :: INT

      .E_pol.create(.mol1.n_atom, .mol2.n_atom)
      E_pol_T.create(.mol2.n_atom, .mol1.n_atom)
      E_pol_T = ZERO

      .get_1way_polarisation_energy(.mol1, .mol2, E_pol_T, 0)
      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            .E_pol(i, j) = E_pol_T(j, i)
         end
      end
      .get_1way_polarisation_energy(.mol2, .mol1, .E_pol, .mol1.n_bf)

      E_pol_T.destroy
   end

   get_1way_polarisation_energy(mol_from, mol_to, E_pol, offset)
      self :: INOUT
      
      mol_from, mol_to :: MOLECULE*
      E_pol :: MAT{REAL}*
      offset :: INT

      e_field, n_field, total_field :: MAT3{REAL}* !Index: atom to, atom from, component
      term, polarisability :: REAL      
      use_charged_values :: BIN
      atom :: ATOM*
      i, j, k :: INT
      
      total_field.create(mol_to.n_atom, mol_from.n_atom, 3)
      .mol.INTS:get_electronic_field_breakdown(mol_from, mol_to, e_field, offset) 
      mol_to.atom.get_nuclear_field_breakdown(mol_from.atom, n_field)
      total_field = e_field + n_field

      use_charged_values = (mol_to.charge /= 0) AND (mol_to.n_atom == 1)
      do i = 1, mol_to.n_atom
         atom => mol_to.atom(i)
         polarisability = atom.Thakkar_atomic_dipole_polarizability(use_charged_values)
         do j = 1, mol_from.n_atom
            do k = 1, mol_from.n_atom
               term = -HALF * polarisability * dot_product(total_field(i, j, :), total_field(i, k, :))
               E_pol(i, j) = E_pol(i, j) + term
            end
         end
      end
      
      e_field.destroy
      n_field.destroy
      total_field.destroy
   end

!Exchange-repulsion interaction
   get_exchange_repulsion_energy_breakdown ::: leaky
      self :: INOUT

      .E_er.create(.mol1.n_atom, .mol2.n_atom)

      .get_repulsion_energy_breakdown
     
      .E_tot.plus(.E_rep)
      .E_er = .E_ex + .E_rep
   end

   get_repulsion_energy_breakdown ::: leaky
      self :: INOUT

      delta_E :: MAT{REAL}*

      .E_rep.create(.mol1.n_atom, .mol2.n_atom)
      delta_E.create(.mol.n_atom, .mol.n_atom)

      .get_contributions_to_repulsion(delta_E)
      .get_repulsion_from_contributions(delta_E)
     
      delta_E.destroy
   end

   get_contributions_to_repulsion(delta_E)
      self :: INOUT

      delta_E :: MAT{REAL}*
      
      delta_dm :: MAT{REAL}*
      
      delta_dm.create(.mol.n_bf, .mol.n_bf)

      delta_dm.to_scaled(.density_matrix, -ONE)
      delta_E = ZERO
      .get_ee_repulsion_and_exchange_energy_breakdown_inner(delta_E, delta_E, .mol, .mol, -HALF, 0)
      
      .mol.SCF:symmorthonormalize_occupied_MOs
      .mol.BASE:make_scf_density_matrix
      delta_dm.plus(.density_matrix)
      
      .get_ee_repulsion_and_exchange_energy_breakdown_inner(delta_E, delta_E, .mol, .mol, HALF, 0)
      .get_ne_attraction_contribution_to_repulsion(delta_E, delta_dm)
      .get_kinetic_contribution_to_repulsion(delta_E, delta_dm)

      delta_dm.destroy
   end

   get_repulsion_from_contributions(delta_E)
      self :: INOUT

      delta_E :: MAT{REAL}*
      
      i, j, jj :: INT
      delta_E_total, E_rep_total :: VEC{REAL}*
      factor :: REAL

      delta_E_total.create(.mol.n_atom)
      E_rep_total.create(.mol.n_atom)
      delta_E_total = ZERO
      E_rep_total = ZERO
      
      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            jj = j + .mol1.n_atom
            .E_rep(i, j) = delta_E(i, jj) + delta_E(jj, i)
            E_rep_total(i) = E_rep_total(i) + .E_rep(i, j)
            E_rep_total(jj) = E_rep_total(jj) + .E_rep(i, j)
         end
      end
 
      do i = 1, .mol1.n_atom
         do j = 1, .mol1.n_atom
            delta_E_total(i) = delta_E_total(i) + delta_E(i, j)
         end
      end

      do i = .mol1.n_atom + 1, .mol.n_atom
         do j = .mol1.n_atom + 1, .mol.n_atom
            delta_E_total(i) = delta_E_total(i) + delta_E(i, j)
         end
      end

      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            jj = j + .mol1.n_atom
            factor = ONE + delta_E_total(i) / E_rep_total(i) + delta_E_total(jj) / E_rep_total(jj)
            .E_rep(i, j) = .E_rep(i, j) * factor 
         end
      end

      delta_E_total.destroy
      E_rep_total.destroy
   end

   get_ne_attraction_contribution_to_repulsion(delta_E, delta_dm)
      self :: IN

      delta_E, delta_dm :: MAT{REAL}*
      
      i :: INT
      E_ne :: MAT{REAL}*

      E_ne.create(.mol.n_atom, .mol.n_atom)
      E_ne = ZERO

      do i = 1, .mol.n_atom
         .mol.INTS:get_one_electron_operator_breakdown(.attraction_mx(i, :, :), E_ne(i, :), delta_dm, 0, HALF)
      end

      delta_E.plus(E_ne)
      E_ne.to_transpose
      delta_E.plus(E_ne)

      E_ne.destroy
   end

   get_kinetic_contribution_to_repulsion(delta_E, delta_dm)
      self :: IN

      delta_E, delta_dm :: MAT{REAL}*
     
      kinetic_mx :: MAT{REAL}*
      shell1, shell2, m, m_start, m_end, n, n_start, n_end, i, j :: INT

      kinetic_mx.create(.mol.n_bf, .mol.n_bf)
      .mol.INTS:make_kinetic_energy_mx(kinetic_mx)
      
      do shell1 = 1, .mol.n_shell
         m_start = .mol.first_basis_fn_for_shell(shell1)
         m_end = .mol.last_basis_fn_for_shell(shell1)
         i = .mol.atom_for_shell(shell1)         
         do m = m_start, m_end
            do shell2 = 1, .mol.n_shell
               n_start = .mol.first_basis_fn_for_shell(shell2)
               n_end = .mol.last_basis_fn_for_shell(shell2) 
               j = .mol.atom_for_shell(shell2)
               do n = n_start, n_end
                  delta_E(i, j) = delta_E(i, j) + delta_dm(m, n) * kinetic_mx(m, n)
               end
            end
         end
      end
      
      kinetic_mx.destroy
   end

!Helper functions
   get_ee_repulsion_and_exchange_energy_breakdown_inner(E_ee, E_ex, mol1, mol2, factor, offset)
      self :: INOUT

      E_ee, E_ex :: MAT{REAL}*
      mol1, mol2 :: MOLECULE*
      factor :: REAL
      offset :: INT
      
      density_term, coulomb_term, exchange_term :: REAL
      shell1, shell2, m_start, m_end, k_start, k_end, i, j, m, n, k, l :: INT

      do shell1 = 1, mol1.n_shell
         m_start = mol1.first_basis_fn_for_shell(shell1)
         m_end = mol1.last_basis_fn_for_shell(shell1)
         i = mol1.atom_for_shell(shell1)         
         do m = m_start, m_end
            do shell2 = 1, mol2.n_shell
               k_start = mol2.first_basis_fn_for_shell(shell2) + offset
               k_end = mol2.last_basis_fn_for_shell(shell2) + offset
               j = mol2.atom_for_shell(shell2)
               do k = k_start, k_end
                  do n = 1, mol1.n_bf 
                     do l = offset + 1, offset + mol2.n_bf
                         density_term = .density_matrix(m, n) * .density_matrix(k, l) * factor
                         coulomb_term = density_term * .ao_2e_ints(m, n, k, l)
                         exchange_term = -QUARTER * density_term * (.ao_2e_ints(m, k, n, l) + .ao_2e_ints(n, k, m, l))
                         E_ee(i, j) = E_ee(i, j) + coulomb_term
                         E_ex(i, j) = E_ex(i, j) + exchange_term
                     end
                  end
               end
            end
         end
      end
   end

!  ========================
!  Group-group calculations 
!  ========================

   get_functional_groups_energy_breakdown ::: leaky
      self :: INOUT

      ENSURE(.groups.created, "no group data")
      ENSURE(.group_pairs.created, "no queries")
      ENSURE(.group_pairs_are_valid, "some queries contain functional groups not on the list") 
      ENSURE(.groups_are_valid, "some atoms within a functional group are not found within the relevant molecule")
      
      .group_energies.create(.group_pairs.dim1, num_interaction_types, num_interaction_directions)
      .get_functional_groups_energy_breakdown_term(.E_el, 1)
      .get_functional_groups_energy_breakdown_term(.E_pol, 2)
      .get_functional_groups_energy_breakdown_term(.E_disp, 3)
      .get_functional_groups_energy_breakdown_term(.E_er, 4)
      .get_functional_groups_energy_breakdown_term(.E_tot, 5)
   end
 
   get_functional_groups_energy_breakdown_term(energy, type_num)
      self :: INOUT
      
      energy :: MAT{REAL}*
      type_num :: INT
 
      i :: INT
 
      do i = 1, .group_pairs.dim1
         .get_group_pair_energy_breakdown(energy, type_num, i)
      end
   end

   get_group_pair_energy_breakdown(energy, type_num, pair_num)
      self :: INOUT
 
      energy :: MAT{REAL}*, IN
      type_num, pair_num :: INT, IN
      
      group1, group2 :: VEC{INT}*
      gge, gme, mge :: MAT{REAL}*
      gg_term, gb_term, bg_term, bb_term :: REAL

      group1 => .groups(.group_pairs(pair_num, 1)).element
      group2 => .groups(.group_pairs(pair_num, 2)).element
      
      gge.create(group1.dim, group2.dim)
      gme.create(group1.dim, energy.dim2)
      mge.create(energy.dim1, group2.dim)

      gge = energy(group1, group2)
      gme = energy(group1, :)
      mge = energy(:, group2)

      gg_term = gge.sum_elements
      gb_term = gme.sum_elements - gg_term
      bg_term = mge.sum_elements - gg_term
      bb_term = energy.sum_elements - gg_term - gb_term - bg_term

      gge.destroy
      gme.destroy
      mge.destroy

      .group_energies(pair_num, type_num, :) = [gg_term, gb_term, bg_term, bb_term]
   end

!  ==============
!  Output methods 
!  ==============

   put_atomic_energy_breakdown
      self :: IN

      stdout.flush
      stdout.text("===============================================")
      stdout.text("Atom-atom breakdown of interaction energy terms")
      stdout.text("===============================================")
      stdout.text("Units: " // .units)

      .put_atom_breakdown_matrix("Nucleus-nucleus repulsion", .E_nn)
      .put_atom_breakdown_matrix("Nucleus-electron attraction", .E_ne)
      .put_atom_breakdown_matrix("Electron-electron repulsion", .E_ee)
      .put_atom_breakdown_matrix("Electrostatic", .E_el)
      .put_atom_breakdown_matrix("Polarisation", .E_pol)
      .put_atom_breakdown_matrix("Dispersion", .E_disp)
      .put_atom_breakdown_matrix("Exchange", .E_ex)
      .put_atom_breakdown_matrix("Repulsion", .E_rep)
      .put_atom_breakdown_matrix("Exchange-repulsion", .E_er)
      .put_atom_breakdown_matrix("Total interaction", .E_tot)
   end

   put_atom_breakdown_matrix(name, matrix)
      self :: IN 
      
      name :: STR
      matrix :: MAT{REAL}*
      
      ENSURE(matrix.created, "no " // name // " energy data")
      
      print_mat :: MAT{REAL}*

      print_mat.create(matrix.dim1, matrix.dim2)
      print_mat.to_scaled(matrix, .conversion_factor)
      
      stdout.text(trim(name) // " energy:")
      stdout.put(print_mat)
      stdout.show("Total = ", print_mat.sum_elements)
      stdout.text(" ")

      print_mat.destroy
   end

   put_functional_group_energy_breakdown
      self :: IN

      ENSURE(.group_pairs.created, "no query data") 
      ENSURE(.group_energies.created, "no functional group energy data") 
      
      i :: INT
      print_mat :: MAT{REAL}*

      print_mat.create(num_interaction_types, num_interaction_directions)

      stdout.flush
      stdout.text("======================================================")
      stdout.text("Functional group breakdown of interaction energy terms")
      stdout.text("======================================================")
      stdout.text("Units: " // .units)
      
      do i = 1, .group_pairs.dim1
         stdout.put("Between group ")
         stdout.put(.group_pairs(i, 1))
         stdout.put(" on molecule 1 and group ")
         stdout.put(.group_pairs(i, 2))
         stdout.put(" on molecule 2:" // char(10) // char(10))
         print_mat  = .group_energies(i, :, :) * .conversion_factor
         stdout.put(print_mat, row_heading, column_heading)
         stdout.put(char(10))
      end

      print_mat.destroy
   end

!  ================
!  Checking methods
!  ================

   check_molecule(mol, number) ::: selfless
      self :: IN

      mol :: MOLECULE*
      number :: STR 

      ENSURE(mol.density_matrix.created, "no density matrix for atom group " // number)
      ENSURE(mol.molecular_orbitals.created, "no molecular orbitals for atom group " // number)
      ENSURE(mol.scfdata.is_restricted, "atom group " // number // " does not have restricted spin orbitals")
      ENSURE(mol.nucleus_model == "point", "atom group " // number // " does not have point as its nucleus model")
   end

   group_sizes_provided result(res)
      self :: IN

      res :: BIN

      if (.groups.dim == 0) then
         res = TRUE
      else
         res = .groups(1).element.created
      end
   end

   group_pairs_are_valid result(res)
      self :: IN

      res :: BIN

      i, j :: INT

      res = TRUE
      do i = 1, .group_pairs.dim1
         do j = 1, num_atom_groups
            res = res AND .group_pairs(i, j) >= 1 AND .group_pairs(i, j) <= .groups.dim
         end
      end
   end

   groups_are_valid result(res)
      self :: IN

      res :: BIN

      i, j, k :: INT
      group :: VEC{INT}*
      
      res = TRUE
      do i = 1, .group_pairs.dim1
         do j = 1, num_atom_groups
            group => .groups(.group_pairs(i, j)).element
            do k = 1, group.dim
               res = res AND (group(k) >= 1) AND (group(k) <= .mol.atom_group(j).mol.n_atom)
            end
         end
      end
   end
end
