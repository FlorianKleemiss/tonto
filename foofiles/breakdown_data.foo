module BREAKDOWN_DATA
   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

   num_interaction_directions :: INT = 4 
   num_interaction_types :: INT = 5 
   column_heading :: VEC{STR}(4) = ["group1-group2", "group1-bulk  ", "bulk-group2  ", "bulk-bulk    "]
   row_heading :: VEC{STR}(5) = ["electrostatic     ", "polarisation      ", "dispersion        ", "exchange-repulsion", "total             "]
   num_atom_groups :: INT = 2

   contains
   
!  ===================
!  Allocation routines
!  ===================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end
   
   nullify_ptr_part
   ! Nullify the pointer parts of self
   ! Check whether need to nullify references to DM, and molecules
      self :: INOUT

      nullify(.E_nn)
      nullify(.E_ne)
      nullify(.E_ee)
      nullify(.E_el)
      nullify(.E_pol)
      nullify(.E_disp)
      nullify(.E_ex)
      nullify(.E_rep)
      nullify(.E_er)
      nullify(.E_tot)
      nullify(.ao_2e_ints)
      nullify(.attraction_mx)
      nullify(.letter_groups)
      nullify(.mol1_groups)
      nullify(.mol2_groups)
      nullify(.group_pairs)
      nullify(.group_energies)
      nullify(.mol)
      nullify(.mol1)
      nullify(.mol2)
      nullify(.density_matrix)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
      .E_nn.destroy
      .E_ne.destroy
      .E_ee.destroy
      .E_el.destroy
      .E_pol.destroy
      .E_disp.destroy
      .E_ex.destroy
      .E_rep.destroy
      .E_er.destroy
      .E_tot.destroy
      .ao_2e_ints.destroy
      .attraction_mx.destroy
      .letter_groups.destroy
      .mol1_groups.destroy
      .mol2_groups.destroy
      .group_pairs.destroy
      .group_energies.destroy
   end

   create_copy(breakdown_data) ::: leaky
   ! Create a copy of the "breakdown_data" object
      self :: PTR
      breakdown_data :: BREAKDOWN_DATA
      .create
      .copy(breakdown_data)
   end

   copy(breakdown_data) ::: leaky
   ! Make a copy of the "breakdown_data" object
      breakdown_data :: BREAKDOWN_DATA 

      self = breakdown_data
      .nullify_ptr_part

      if (breakdown_data.E_nn.created) .E_nn.create_copy(breakdown_data.E_nn)
      if (breakdown_data.E_ne.created) .E_ne.create_copy(breakdown_data.E_ne)
      if (breakdown_data.E_ee.created) .E_ee.create_copy(breakdown_data.E_ee)
      if (breakdown_data.E_pol.created) .E_pol.create_copy(breakdown_data.E_pol)
      if (breakdown_data.E_pol.created) .E_pol.create_copy(breakdown_data.E_pol)
      if (breakdown_data.E_disp.created) .E_disp.create_copy(breakdown_data.E_disp)
      if (breakdown_data.E_ex.created) .E_ex.create_copy(breakdown_data.E_ex)
      if (breakdown_data.E_rep.created) .E_rep.create_copy(breakdown_data.E_rep)
      if (breakdown_data.E_er.created) .E_er.create_copy(breakdown_data.E_er)
      if (breakdown_data.E_tot.created) .E_tot.create_copy(breakdown_data.E_tot)
      if (breakdown_data.ao_2e_ints.created) .ao_2e_ints.create_copy(breakdown_data.ao_2e_ints)
      if (breakdown_data.attraction_mx.created) .attraction_mx.create_copy(breakdown_data.attraction_mx)
      if (breakdown_data.mol1_groups.created) .mol1_groups.create_copy(breakdown_data.mol1_groups)
      if (breakdown_data.mol2_groups.created) .mol2_groups.create_copy(breakdown_data.mol2_groups)
      if (breakdown_data.letter_groups.created) .letter_groups.create_copy(breakdown_data.letter_groups)
      if (breakdown_data.group_pairs.created) .group_pairs.create_copy(breakdown_data.group_pairs)
      if (breakdown_data.group_energies.created) .group_energies.create_copy(breakdown_data.group_energies)

      if (breakdown_data.mol1.created) .mol1 => breakdown_data.mol1 
      if (breakdown_data.mol2.created) .mol2 => breakdown_data.mol2 
      if (breakdown_data.density_matrix.created) .density_matrix => breakdown_data.density_matrix 
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default breakdown data object
      .units = "hartrees"
      .conversion_factor = ONE
   end
   
!  ===============
!  General methods 
!  ===============

   put(mol) ::: leaky
      self :: INOUT

      mol :: MOLECULE*

      ENSURE(mol.atom_group.created, "no atom group information")
      ENSURE(mol.atom_group.dim == num_atom_groups, "must have only 2 atom groups")
      BREAKDOWN_DATA:check_molecule(mol.atom_group(1).mol, "1")
      BREAKDOWN_DATA:check_molecule(mol.atom_group(2).mol, "2")

      .mol => mol
      
      .read_keywords
      .get_atom_energy_breakdown
      .process_groups
      BREAKDOWN_DATA::put_vec_vec_vec(.mol1_groups)
      BREAKDOWN_DATA::put_vec_vec_vec(.mol2_groups)
      .get_functional_groups_energy_breakdown
      .put_atomic_energy_breakdown
      .put_functional_group_energy_breakdown
   end

!  =============
!  Input methods 
!  =============

   read_keywords ::: get_from(OBJECT), leaky
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                      ")  ! exit read_loop
         case ("groups=                "); .read_letter_groups
         case ("group_sizes=           "); .read_group_sizes
         case ("num_groups=            "); .read_num_groups
         case ("num_queries=           "); .read_num_group_pairs
         case ("queries=               "); .read_group_pairs
         case ("units=                 "); .read_units
         case default;       UNKNOWN(word)
      end

   end

   read_units ::: leaky
      self :: INOUT
      
      units_lower :: STR

      stdin.read(.units)
      units_lower = trim(.units)
      units_lower.to_lower_case
      if (units_lower == "hartree" OR units_lower == "hartrees") then
         .conversion_factor = ONE
      else
         .conversion_factor = .units.conversion_factor 
      end
   end
   
   read_num_groups ::: leaky
      self :: INOUT

      num_groups :: INT

      stdin.read(num_groups)
      .letter_groups.create(num_groups)
   end

   read_group_sizes ::: leaky
      self :: INOUT

      ENSURE(.letter_groups.created, "number of groups must be provided before group sizes")

      i :: INT
      group_sizes :: VEC{INT}(.letter_groups.dim)

      stdin.read(group_sizes)

      do i = 1, .letter_groups.dim
         .letter_groups(i).element.create(group_sizes(i))
      end
   end

   read_letter_groups ::: leaky
      self :: INOUT

      ENSURE(.letter_groups.created, "number of groups must be provided before groups")
      ENSURE(.group_sizes_nonzero, "groups cannot have size zero")
      ENSURE(.group_sizes_provided, "group sizes must be provided before groups")

      i :: INT

      do i = 1, .letter_groups.dim
         stdin.read(.letter_groups(i).element)
      end
   end

   read_num_group_pairs ::: leaky
      self :: INOUT

      num_group_pairs :: INT

      stdin.read(num_group_pairs)
      .group_pairs.create(num_group_pairs, num_atom_groups)
      .group_pairs = 0
   end

   read_group_pairs
      self :: INOUT

      ENSURE(.group_pairs.created, "number of queries must be read in before queries")

      stdin.read(.group_pairs)
   end
   
!  ======================
!  Atom-atom calculations 
!  ======================
   
   get_atom_energy_breakdown ::: private, private, leaky
      self :: INOUT

      atom_group1, atom_group2 :: ATOM_GROUP*
      
      atom_group1 => .mol.atom_group(1)
      atom_group2 => .mol.atom_group(2)
      .mol1 => atom_group1.mol
      .mol2 => atom_group2.mol
      
      .ao_2e_ints.create(.mol.n_bf, .mol.n_bf, .mol.n_bf, .mol.n_bf)
      .E_tot.create(.mol1.n_atom, .mol2.n_atom)

      .mol.SCF:merge_group_MOs
      .mol.BASE:make_scf_density_matrix
      .density_matrix => .mol.density_matrix.restricted
      .mol.FOCK:make_ERI_integrals(.ao_2e_ints)

      .get_electrostatic_exchange_energy_breakdown
      .get_polarisation_energy_breakdown
      .mol1.atom.get_dispersion_energy_breakdown(.mol2.atom, .E_disp)
      .E_tot = .E_el + .E_disp + .E_pol + .E_ex
      .get_exchange_repulsion_energy_breakdown
   end

!Electrostatic and exchange interaction
   get_electrostatic_exchange_energy_breakdown ::: private, private, leaky
      self :: INOUT
      
      .E_el.create(.mol1.n_atom, .mol2.n_atom)

      .mol1.atom.get_nn_repulsion_energy_breakdown(.mol2.atom, .E_nn)
      .get_ne_attraction_energy_breakdown
      .get_ee_repulsion_and_exchange_energy_breakdown

      .E_el = .E_nn + .E_ne + .E_ee
   end

   get_ne_attraction_energy_breakdown ::: private, leaky
      self :: INOUT
      
      i :: INT

      .E_ne.create(.mol1.n_atom, .mol2.n_atom) !Indexing:.molecule1-.molecule2
      .E_ne = ZERO

      .attraction_mx.create(.mol.n_atom, .mol.n_bf, .mol.n_bf)
      .mol.INTS:get_nuclear_attraction_by_nucleus_matrices(.attraction_mx)
      do i = 1, .mol1.n_atom
         .mol2.INTS:get_one_electron_operator_breakdown(.attraction_mx(i, :, :), .E_ne(i, :), .density_matrix, .mol1.n_bf, ONE)
      end
      do i = 1, .mol2.n_atom
         .mol1.INTS:get_one_electron_operator_breakdown(.attraction_mx(i + .mol1.n_atom, :, :), .E_ne(:, i), .density_matrix, 0, ONE)
      end
   end

   get_ee_repulsion_and_exchange_energy_breakdown ::: private, leaky
      self :: INOUT
      
      .E_ee.create(.mol1.n_atom, .mol2.n_atom)
      .E_ex.create(.mol1.n_atom, .mol2.n_atom)
      .E_ee = ZERO
      .E_ex = ZERO

      .get_ee_repulsion_and_exchange_energy_breakdown_inner(.E_ee, .E_ex, .mol1, .mol2, ONE, .mol1.n_bf)      
   end

!Polarisation interaction
   get_polarisation_energy_breakdown ::: private, leaky
      self :: INOUT
      
      E_pol_T :: MAT{REAL}*
      i, j :: INT

      .E_pol.create(.mol1.n_atom, .mol2.n_atom)
      E_pol_T.create(.mol2.n_atom, .mol1.n_atom)
      E_pol_T = ZERO

      .get_1way_polarisation_energy(.mol1, .mol2, E_pol_T, 0)
      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            .E_pol(i, j) = E_pol_T(j, i)
         end
      end
      .get_1way_polarisation_energy(.mol2, .mol1, .E_pol, .mol1.n_bf)

      E_pol_T.destroy
   end

   get_1way_polarisation_energy(mol_from, mol_to, E_pol, offset) ::: private
      self :: INOUT
      
      mol_from, mol_to :: MOLECULE*
      E_pol :: MAT{REAL}*
      offset :: INT

      e_field, n_field, total_field :: MAT3{REAL}* !Index: atom to, atom from, component
      term, polarisability :: REAL      
      use_charged_values :: BIN
      atom :: ATOM*
      i, j, k :: INT
      
      total_field.create(mol_to.n_atom, mol_from.n_atom, 3)
      .mol.INTS:get_electronic_field_breakdown(mol_from, mol_to, e_field, offset) 
      mol_to.atom.get_nuclear_field_breakdown(mol_from.atom, n_field)
      total_field = e_field + n_field

      use_charged_values = (mol_to.charge /= 0) AND (mol_to.n_atom == 1)
      do i = 1, mol_to.n_atom
         atom => mol_to.atom(i)
         polarisability = atom.Thakkar_atomic_dipole_polarizability(use_charged_values)
         do j = 1, mol_from.n_atom
            do k = 1, mol_from.n_atom
               term = -HALF * polarisability * dot_product(total_field(i, j, :), total_field(i, k, :))
               E_pol(i, j) = E_pol(i, j) + term
            end
         end
      end
      
      e_field.destroy
      n_field.destroy
      total_field.destroy
   end

!Exchange-repulsion interaction
   get_exchange_repulsion_energy_breakdown ::: private, leaky
      self :: INOUT

      .E_er.create(.mol1.n_atom, .mol2.n_atom)

      .get_repulsion_energy_breakdown
     
      .E_tot.plus(.E_rep)
      .E_er = .E_ex + .E_rep
   end

   get_repulsion_energy_breakdown ::: private, leaky
      self :: INOUT

      delta_E :: MAT{REAL}*

      .E_rep.create(.mol1.n_atom, .mol2.n_atom)
      delta_E.create(.mol.n_atom, .mol.n_atom)

      .get_contributions_to_repulsion(delta_E)
      .get_repulsion_from_contributions(delta_E)
     
      delta_E.destroy
   end

   get_contributions_to_repulsion(delta_E) ::: private
      self :: INOUT

      delta_E :: MAT{REAL}*
      
      delta_dm :: MAT{REAL}*
      
      delta_dm.create(.mol.n_bf, .mol.n_bf)

      delta_dm.to_scaled(.density_matrix, -ONE)
      delta_E = ZERO
      .get_ee_repulsion_and_exchange_energy_breakdown_inner(delta_E, delta_E, .mol, .mol, -HALF, 0)
      
      .mol.SCF:symmorthonormalize_occupied_MOs
      .mol.BASE:make_scf_density_matrix
      delta_dm.plus(.density_matrix)
      
      .get_ee_repulsion_and_exchange_energy_breakdown_inner(delta_E, delta_E, .mol, .mol, HALF, 0)
      .get_ne_attraction_contribution_to_repulsion(delta_E, delta_dm)
      .get_kinetic_contribution_to_repulsion(delta_E, delta_dm)

      delta_dm.destroy
   end

   get_repulsion_from_contributions(delta_E) ::: private
      self :: INOUT

      delta_E :: MAT{REAL}*
      
      i, j, jj :: INT
      delta_E_total, E_rep_total :: VEC{REAL}*
      factor :: REAL

      delta_E_total.create(.mol.n_atom)
      E_rep_total.create(.mol.n_atom)
      delta_E_total = ZERO
      E_rep_total = ZERO
      
      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            jj = j + .mol1.n_atom
            .E_rep(i, j) = delta_E(i, jj) + delta_E(jj, i)
            E_rep_total(i) = E_rep_total(i) + .E_rep(i, j)
            E_rep_total(jj) = E_rep_total(jj) + .E_rep(i, j)
         end
      end
 
      do i = 1, .mol1.n_atom
         do j = 1, .mol1.n_atom
            delta_E_total(i) = delta_E_total(i) + delta_E(i, j)
         end
      end

      do i = .mol1.n_atom + 1, .mol.n_atom
         do j = .mol1.n_atom + 1, .mol.n_atom
            delta_E_total(i) = delta_E_total(i) + delta_E(i, j)
         end
      end

      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            jj = j + .mol1.n_atom
            factor = ONE + delta_E_total(i) / E_rep_total(i) + delta_E_total(jj) / E_rep_total(jj)
            .E_rep(i, j) = .E_rep(i, j) * factor 
         end
      end

      delta_E_total.destroy
      E_rep_total.destroy
   end

   get_ne_attraction_contribution_to_repulsion(delta_E, delta_dm) ::: private
      self :: IN

      delta_E, delta_dm :: MAT{REAL}*
      
      i :: INT
      E_ne :: MAT{REAL}*

      E_ne.create(.mol.n_atom, .mol.n_atom)
      E_ne = ZERO

      do i = 1, .mol.n_atom
         .mol.INTS:get_one_electron_operator_breakdown(.attraction_mx(i, :, :), E_ne(i, :), delta_dm, 0, HALF)
      end

      delta_E.plus(E_ne)
      E_ne.to_transpose
      delta_E.plus(E_ne)

      E_ne.destroy
   end

   get_kinetic_contribution_to_repulsion(delta_E, delta_dm) ::: private
      self :: IN

      delta_E, delta_dm :: MAT{REAL}*
     
      kinetic_mx :: MAT{REAL}*
      shell1, shell2, m, m_start, m_end, n, n_start, n_end, i, j :: INT

      kinetic_mx.create(.mol.n_bf, .mol.n_bf)
      .mol.INTS:make_kinetic_energy_mx(kinetic_mx)
      
      do shell1 = 1, .mol.n_shell
         m_start = .mol.first_basis_fn_for_shell(shell1)
         m_end = .mol.last_basis_fn_for_shell(shell1)
         i = .mol.atom_for_shell(shell1)         
         do m = m_start, m_end
            do shell2 = 1, .mol.n_shell
               n_start = .mol.first_basis_fn_for_shell(shell2)
               n_end = .mol.last_basis_fn_for_shell(shell2) 
               j = .mol.atom_for_shell(shell2)
               do n = n_start, n_end
                  delta_E(i, j) = delta_E(i, j) + delta_dm(m, n) * kinetic_mx(m, n)
               end
            end
         end
      end
      
      kinetic_mx.destroy
   end

!Helper functions
   get_ee_repulsion_and_exchange_energy_breakdown_inner(E_ee, E_ex, mol1, mol2, factor, offset) ::: private
      self :: INOUT

      E_ee, E_ex :: MAT{REAL}*
      mol1, mol2 :: MOLECULE*
      factor :: REAL
      offset :: INT
      
      density_term, coulomb_term, exchange_term :: REAL
      shell1, shell2, m_start, m_end, k_start, k_end, i, j, m, n, k, l :: INT

      do shell1 = 1, mol1.n_shell
         m_start = mol1.first_basis_fn_for_shell(shell1)
         m_end = mol1.last_basis_fn_for_shell(shell1)
         i = mol1.atom_for_shell(shell1)         
         do m = m_start, m_end
            do shell2 = 1, mol2.n_shell
               k_start = mol2.first_basis_fn_for_shell(shell2) + offset
               k_end = mol2.last_basis_fn_for_shell(shell2) + offset
               j = mol2.atom_for_shell(shell2)
               do k = k_start, k_end
                  do n = 1, mol1.n_bf 
                     do l = offset + 1, offset + mol2.n_bf
                         density_term = .density_matrix(m, n) * .density_matrix(k, l) * factor
                         coulomb_term = density_term * .ao_2e_ints(m, n, k, l)
                         exchange_term = -QUARTER * density_term * (.ao_2e_ints(m, k, n, l) + .ao_2e_ints(n, k, m, l))
                         E_ee(i, j) = E_ee(i, j) + coulomb_term
                         E_ex(i, j) = E_ex(i, j) + exchange_term
                     end
                  end
               end
            end
         end
      end
   end

!  ========================
!  Group-group calculations 
!  ========================
   
   process_groups ::: private
      self :: INOUT

      ENSURE(.symbols_are_valid, "invalid symbol detected")

      .mol1.PROP:find_groups(.letter_groups, .mol1_groups)
      .mol2.PROP:find_groups(.letter_groups, .mol2_groups)
   end

   get_functional_groups_energy_breakdown ::: private, leaky
      self :: INOUT

      ENSURE(.groups_present, "group not found in either molecule")
      ENSURE(.group_pairs_are_valid, "group not found in the relevant molecule")

      num_pairs, i :: INT

      num_pairs = 0
      do i = 1, .group_pairs.dim1
         num_pairs = num_pairs + .mol1_groups(.group_pairs(i, 1)).element.dim * .mol2_groups(.group_pairs(i, 2)).element.dim
      end
      
      .group_energies.create(num_pairs, num_interaction_types, num_interaction_directions)
      .get_functional_groups_energy_breakdown_term(.E_el, 1)
      .get_functional_groups_energy_breakdown_term(.E_pol, 2)
      .get_functional_groups_energy_breakdown_term(.E_disp, 3)
      .get_functional_groups_energy_breakdown_term(.E_er, 4)
      .get_functional_groups_energy_breakdown_term(.E_tot, 5)
   end
   
   get_functional_groups_energy_breakdown_term(energy, type_num) ::: private
      self :: INOUT
      energy :: MAT{REAL}*
      type_num :: INT
 
      i, j, k, l :: INT
      list1, list2 :: VEC{VEC_{INT}}*
      group1, group2 :: VEC{INT}*
     
      l = 0
      do i = 1, .group_pairs.dim1
         list1 => .mol1_groups(.group_pairs(i, 1)).element
         list2 => .mol2_groups(.group_pairs(i, 2)).element
         do j = 1, list1.dim 
            group1 => list1(j).element 
            do k = 1, list2.dim 
               l = l + 1
               group2 => list2(k).element 
               .get_group_pair_energy_breakdown(energy, type_num, l, group1, group2)
            end
         end
      end
   end

   get_group_pair_energy_breakdown(energy, type_num, pair_num, group1, group2) ::: private
      self :: INOUT
      energy :: MAT{REAL}*, IN
      type_num, pair_num :: INT, IN
      group1, group2 :: VEC{INT}*
      
      gge, gme, mge :: MAT{REAL}*
      gg_term, gb_term, bg_term, bb_term :: REAL

      gge.create(group1.dim, group2.dim)
      gme.create(group1.dim, energy.dim2)
      mge.create(energy.dim1, group2.dim)

      gge = energy(group1, group2)
      gme = energy(group1, :)
      mge = energy(:, group2)

      gg_term = gge.sum_elements
      gb_term = gme.sum_elements - gg_term
      bg_term = mge.sum_elements - gg_term
      bb_term = energy.sum_elements - gg_term - gb_term - bg_term

      gge.destroy
      gme.destroy
      mge.destroy

      .group_energies(pair_num, type_num, :) = [gg_term, gb_term, bg_term, bb_term]
   end

!  ==============
!  Output methods 
!  ==============

   put_atomic_energy_breakdown ::: private
      self :: IN

      stdout.flush
      !.mol1.PROP:put_mulliken_populations
      !.mol2.PROP:put_mulliken_populations
      stdout.text("===============================================")
      stdout.text("Atom-atom breakdown of interaction energy terms")
      stdout.text("===============================================")
      stdout.text("Units: " // .units)

      .put_test_matrices
      .put_atom_breakdown_matrix("Nucleus-nucleus repulsion", .E_nn)
      .put_atom_breakdown_matrix("Nucleus-electron attraction", .E_ne)
      .put_atom_breakdown_matrix("Electron-electron repulsion", .E_ee)
      .put_atom_breakdown_matrix("Electrostatic", .E_el)
      .put_atom_breakdown_matrix("Polarisation", .E_pol)
      .put_atom_breakdown_matrix("Dispersion", .E_disp)
      .put_atom_breakdown_matrix("Exchange", .E_ex)
      .put_atom_breakdown_matrix("Repulsion", .E_rep)
      .put_atom_breakdown_matrix("Exchange-repulsion", .E_er)
      .put_atom_breakdown_matrix("Total interaction", .E_tot)
   end

   put_atom_breakdown_matrix(name, matrix) ::: private
      self :: IN 
      
      name :: STR
      matrix :: MAT{REAL}*
      
      print_mat :: MAT{REAL}*

      print_mat.create(matrix.dim1, matrix.dim2)
      print_mat.to_scaled(matrix, .conversion_factor)
      
      stdout.text(trim(name) // " energy:")
      stdout.put(print_mat)
      stdout.show("Total = ", print_mat.sum_elements)
      stdout.text(" ")

      print_mat.destroy
   end

   put_functional_group_energy_breakdown ::: private
      self :: IN

      i, j, k, l :: INT
      list1, list2 :: VEC{VEC_{INT}}*
      print_mat :: MAT{REAL}*

      print_mat.create(num_interaction_types, num_interaction_directions)

      stdout.text("======================================================")
      stdout.text("Functional group breakdown of interaction energy terms")
      stdout.text("======================================================")
      stdout.text("Units: " // .units)
      
      l = 0
      do i = 1, .group_pairs.dim1
         list1 => .mol1_groups(.group_pairs(i, 1)).element
         list2 => .mol2_groups(.group_pairs(i, 2)).element
         do j = 1, list1.dim 
            do k = 1, list2.dim
               l = l + 1
               stdout.text("Between group " // trim(.printed_group(i, 1)) // " on molecule 1 and group " // trim(.printed_group(i, 2)) // " on molecule 2:")
               .put_minimum_interatomic_distance(list1(j).element, list2(k).element)
               print_mat = .group_energies(l, :, :) * .conversion_factor
               stdout.put(print_mat, row_heading, column_heading)
               stdout.put(char(10))
            end
         end
      end

      print_mat.destroy
   end

   put_minimum_interatomic_distance(group1, group2)
      self :: IN
      group1, group2 :: VEC{INT}*
      
      atoms1, atoms2 :: VEC{ATOM}*

      atoms1.create_copy(.mol1.atom(group1))
      atoms2.create_copy(.mol2.atom(group2))

      atoms1.put_minimum_interatomic_distance(atoms2)

      atoms1.destroy
      atoms2.destroy
   end

   printed_group(i, j) result(res)
      self :: IN
      i, j :: INT
      res :: STR

      res = .letter_groups(.group_pairs(i, j)).element.to_concatenated_str(separator = trim(" "))
   end

!  ================
!  Checking methods
!  ================

   check_molecule(mol, number) ::: selfless
      self :: IN

      mol :: MOLECULE*
      number :: STR 

      ENSURE(mol.density_matrix.created, "no density matrix for atom group " // number)
      ENSURE(mol.molecular_orbitals.created, "no molecular orbitals for atom group " // number)
      ENSURE(mol.scfdata.is_restricted, "atom group " // number // " does not have restricted spin orbitals")
      ENSURE(mol.nucleus_model == "point", "atom group " // number // " does not have point as its nucleus model")
   end

   group_sizes_provided result(res)
      self :: IN

      res :: BIN

      if (.letter_groups.dim == 0) then
         res = TRUE
      else
         res = .letter_groups(1).element.created
      end
   end

   group_sizes_nonzero result(res)
      self :: IN
      res :: BIN

      i :: INT

      res = TRUE
      do i = 1, .letter_groups.dim
         res = res AND (.letter_groups(i).element.dim > 0)
      end
   end

   symbols_are_valid result(res)
      self :: IN
      res :: BIN

      i, j :: INT
      element :: VEC{STR}*
      symbol :: STR*

      res = TRUE
      do i = 1, .letter_groups.dim
         element => .letter_groups(i).element
         do j = 1, element.dim
            symbol => element(j)
            res = res AND symbol.is_one_of(ATOM::element_symbols)
         end
      end
   end

   groups_present result(res)
      self :: IN
      res :: BIN
      
      i :: INT

      res = TRUE
      do i = 1, .mol1_groups.dim
         res = res AND ((.mol1_groups(i).element.created OR .mol2_groups(i).element.created))
      end
   end

   group_pairs_are_valid result(res)
      self :: IN

      res :: BIN

      i, j, group :: INT

      res = TRUE
      do i = 1, .group_pairs.dim1
         do j = 1, num_atom_groups
            group = .group_pairs(i, j)
            res = res AND group >= 1 AND group <= .mol1_groups.dim
         end
      end
      
      if (res) then
         do i = 1, .group_pairs.dim1
            res = res AND .mol1_groups(.group_pairs(i, 1)).element.created AND .mol2_groups(.group_pairs(i, 2)).element.created
         end
      end
   end

!  =================
!  Testing Functions 
!  =================
   
   put_vec_vec_vec(v) ::: selfless
      v :: VEC{VEC_{VEC_{INT}}}*
      i :: INT
      element :: VEC{VEC_{INT}}*

      do i = 1, v.dim
         stdout.show("Super-vector", i)
         element => v(i).element
         if (element.created) then
            BREAKDOWN_DATA::put_vec_vec(element) 
         end
      end
   end

   put_vec_vec(v) ::: selfless
      v :: VEC{VEC_{INT}}*
      i :: INT
      element :: VEC{INT}*

      do i = 1, v.dim
         stdout.show("Vector", i)
         element => v(i).element
         if (element.created) then
            stdout.put(element)
         end
      end
   end

   put_test_matrices
      self :: IN

      nncp, necp, ne_field, ee_field, eecp, distance :: MAT{REAL}*
      pop1, pop2 :: VEC{REAL}*
      r :: VEC{REAL}(3)
      i, j :: INT
      charge1, charge2, d :: REAL
      
      nncp.create(.mol1.n_atom, .mol2.n_atom)
      necp.create(.mol1.n_atom, .mol2.n_atom)
      eecp.create(.mol1.n_atom, .mol2.n_atom)
      ne_field.create(.mol1.n_atom, .mol2.n_atom)
      ee_field.create(.mol1.n_atom, .mol2.n_atom)
      distance.create(.mol1.n_atom, .mol2.n_atom)
      
      .mol1.PROP:get_mulliken_pop(pop1) 
      .mol2.PROP:get_mulliken_pop(pop2) 

      do i = 1, .mol1.n_atom
         do j = 1, .mol2.n_atom
            charge1 = .mol1.atom(i).nuclear_charge
            charge2 = .mol2.atom(j).nuclear_charge
            r = .mol1.atom(i).position - .mol2.atom(j).position
            d = sqrt(dot_product(r, r))
            distance(i, j) = d
            nncp(i, j) = charge1 * charge2 
            necp(i, j) = -charge1 * pop2(j) - charge2 * pop1(i)
            eecp(i, j) = pop1(i) * pop2(j)
            ne_field(i, j) = necp(i, j) / d
            ee_field(i, j) = eecp(i, j) / d
         end
      end

      stdout.text("Distances:") 
      stdout.put(distance)
      stdout.put(char(10))
      stdout.text("Nucleus-nucleus charge products:") 
      stdout.put(nncp)
      stdout.put(char(10))
      stdout.text("Nucleus-electron charge products:")
      stdout.put(necp)
      stdout.put(char(10))
      stdout.text("Electron-electron charge products:")
      stdout.put(eecp)
      stdout.put(char(10))
      stdout.text("Nucleus-electron attraction energy approximations:")
      stdout.put(ne_field)
      stdout.put(char(10))
      stdout.text("Electron-electron attraction energy approximations:")
      stdout.put(ee_field)
      stdout.put(char(10))

      nncp.destroy
      necp.destroy
      eecp.destroy
      ne_field.destroy
      ee_field.destroy
      distance.destroy
      pop1.destroy
      pop2.destroy
   end
end
