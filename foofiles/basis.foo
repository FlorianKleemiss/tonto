!-------------------------------------------------------------------------------
!
! BASIS: For gaussian basis sets
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module BASIS

   implicit none

   keys :: VEC{STR}@, private

contains

!  =================
!  Memory allocation
!  =================

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   created result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has been allocated
   end

   destroyed result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has *not* been allocated
   end

!  ===========
!  Set methods
!  ===========

   set_spherical(val) ::: pure
   ! Set sphericals to "val" defaults
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

      if (.shell.created) .shell.set_spherical(val)

      .update

   end

   set_label(label) ::: pure
   ! Set the basis label
      self :: INOUT
      label :: STR, IN

      .label = label

   end

!  ======
!  Update
!  ======

   update ::: pure
   ! Update the shell data, if it exists
      self :: INOUT

      if (.shell.destroyed) return

      .n_shell = .shell.dim
      .n_bf    = .shell.no_of_basis_functions
      .n_prim  = .shell.no_of_primitives

   end

   resolve_by_label(label,basis,clobber,minmatch,found)
   ! Resolve "self" by copying the element in "basis" which has a
   ! matching "label". 
   ! . If "clobber" is present and FALSE, and if "self" is already
   !   assigned to a basis with non-blank label, then nothing is done.
   ! . If "minmatch" is present, then a match is made to the number of
   !   characters in "label" even if there are more characters in
   !   "basis.label". This is useful for matching e.g. label "Mg:" 
   !   to basis.label "Mg:gaussian"
   ! . If "found" is present, it is set TRUE if "self" was resolved (or
   !   was already resolved if clobber was set FALSE). Otherwise it is
   !   set FALSE. If "found" is not present, and a match has not been
   !   found, the routine dies.
      self :: allocatable, INOUT
      label :: STR, IN
      basis :: VEC{BASIS}@, IN
      clobber,minmatch :: BIN, optional, IN
      found :: BIN, optional, OUT

      b :: INT
      check :: VEC{BIN}@
      bash,fnd,minmtch :: BIN

      bash = TRUE
      if (present(clobber)) bash = clobber

      ! If we don't clobber and the basis is created and it has a
      ! label, then it is already resolved ... so return.
      if (NOT bash) then
      if (.created) then
      if (.label/=" ") then
         if (present(found)) found = TRUE
         return
      end
      end
      end

      ! Find out if we are doing a minimal match
      minmtch = FALSE
      if (present(minmatch)) minmtch = minmatch

      ! Find where the matching label is ...
      check.create(basis.dim)
      if (minmtch) then; check = basis.label(1:len_trim(label))==label
      else;              check = basis.label==label
      end
      b = check.index_of_first_true_element
      check.destroy

      ! If there was a match, copy the basis, else clobber it.
      fnd = b>0
      if (fnd) then; self = basis(b) 
      else;          self.destroy
      end

      ! Assign "found" or die
      if (present(found)) then; found = fnd
      else if (NOT fnd)   then; DIE("unknown basis label, "// trim(label))
      end

   end

!  =============
!  Put to/get in
!  =============

   get_lc_bf_ex_cc(lc,bf,ex,cc) ::: PURE
   ! Get the l character value symbols, exponents and contractions for
   ! each *primitive* shell
      self :: target, IN
      lc,bf :: VEC{STR}, OUT
      ex,cc :: VEC{REAL}, OUT

   ENSURE(.shell.created,"no shell")
   ENSURE(lc.dim==.shell.no_of_primitive_shells,"wrong size, lc")
   ENSURE(bf.dim==lc.dim,"wrong size, bf")
   ENSURE(ex.dim==lc.dim,"wrong size, ex")
   ENSURE(cc.dim==lc.dim,"wrong size, cc")

      s,c,i,b :: INT
      sh :: SHELL@

      i = 1
      b = 1

      do s = 1,.n_shell 

         sh => .shell(s)
         lc(i) = sh.l_chr
         bf(i) = b.to_str

         do c = 1,sh.n_cc
            ex(i) = sh.exponent(c)
            cc(i) = sh.contraction(c)
            i = i + 1
         end

         b = b + sh.n_bf

      end

   end

!  ===============
!  Inquiry methods
!  ===============

   same_as(b) result (res) ::: pure
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: BASIS, IN
      res :: BIN

      res = .shell.same_as(b.shell) 

   end

   is_resolved result (res) ::: pure
   ! Return TRUE if self is resolved i.e. has shells
      self :: IN
      res :: BIN

      res = .shell.created

   end

   is_created_and_resolved result (res) ::: pure
   ! Return TRUE if self is resolved
      self :: allocatable, IN
      res :: BIN

      res = .created
      if (res) res = .shell.created

   end

   is_created_and_has_label result (res) ::: pure
   ! Return TRUE if self has a non-blank label
      self :: allocatable, INOUT
      res :: BIN
      res = .created
      if (res) res = .label /=  " "
   end

!  =========================
!  Normalisation/contraction
!  =========================

   unnormalise ::: PURE
   ! Take the normalisation factors out of the primitives, assuming
   ! that the contraction coeff's refer to normalised basis functions
      self :: INOUT

      .shell.unnormalise

   end

   renormalise ::: PURE
   ! Put back in the normalisation factors of the primitives, assuming
   ! that the contraction coeff's refer to unnormalised basis functions
      self :: INOUT

      .shell.renormalise

   end

   make_contraction_matrix(ccm) ::: PURE
   ! Set the contraction coefficient matrix "ccm".
   ! Primitives are assumed to have uniform normalisation.
      self :: target, IN
      ccm :: MAT{REAL}, OUT

   ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
   ENSURE(ccm.dim2==.n_bf,  "wrong 2nd dimension, ccm")

      b,p,n_p,n_b,i :: INT
      sh :: SHELL@

      ccm = ZERO

      p = 0                       ! no of primitives in all previous shells
      b = 0                       ! basis number


      do i = 1,.n_shell           ! For segmented basis sets !

         sh => .shell(i)

         n_b = sh.n_bf
         n_p = sh.n_prim

         sh.make_contraction_matrix(ccm(p+1:p+n_p,b+1:b+n_b))

         b = b + n_b
         p = p + n_p

      end

   end

!  ==============
!  Input routines
!  ==============

   read_keywords ::: get_from(OBJECT), leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the
   ! "keyword" is inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}            "); ! exit surrounding loop
      case ("gamess-us=   "); .read_gamess_us
      case ("junk=        "); .read_junk
      case ("label=       "); .read_label
      case ("shells=      "); .read_shell
      case ("units=       "); .read_units
      case ("put          "); .put
      case ("tonto-style= "); .read_tonto_style
      case ("turbomole=   "); .read_turbomole
      case default;           UNKNOWN(word)
      end

   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_label
   ! Read only the basis label
      self :: INOUT

      stdin.read(.label)

   ENSURE(.label(1:1).is_alphabetical,"label must begin with alphabetical character")

   end

   read_shell ::: leaky
   ! Read a shell
      self :: INOUT

      .shell.read_list_keywords

      .update

   end

   read_tonto_style ::: leaky
   ! Create and read a tonto style basis set
      self :: INOUT

      .read_label

      .shell.set_keys(["l_chr=","n_cc= ","ex,cc="])
      .shell.read_data

      .update

   end

   read_gamess_us ::: leaky
   ! Create and read a GAMESS-US style basis set
      self :: INOUT

      .read_label

      .shell.set_keys(["l_chr=     ","n_cc=      ","junk,ex,cc="])
      .shell.read_data

      .update

   end

   read_turbomole ::: leaky
   ! Create and read a turbomole style basis set
      self :: INOUT

      .read_label

      .shell.set_keys(["n_cc= ","l_chr=","ex,cc="])
      .shell.read_data

      .update

   end

   read_molden ::: leaky
   ! Create and read a Molden style basis set
      self :: INOUT

      .read_junk
      .read_junk

      .shell.set_keys(["l_chr=","n_cc= ","junk= ","ex,cc="])
      .shell.read_data_BL_terminated ! Note BL termination

      .update

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), selfless, leaky
   ! Read the "keys" module variable.
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each keyword in the "keys" module variable.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("label",.label)
      stdout.dump("is_spherical",.is_spherical)
      stdout.dump("n_shell",.n_shell)
      stdout.dump("n_bf",.n_bf)
      stdout.dump("n_prim",.n_prim)
      .shell.dmpa("shell")

   end

   dump(object_name,ptr) ::: get_from(OBJECT)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT)
   ! Dump pointer object data as text
   end

!  ======
!  Output
!  ======

   put
   ! Put out the basis information to file "stdout"
      self :: IN

   ENSURE(.shell.created,"no shells")

      ex,cc :: VEC{REAL}@
      lc,bf :: VEC{STR}@
      ns :: INT
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("Basis set "//trim(.label))
      stdout.flush
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)

      ! Get table column data
      ns = .shell.no_of_primitive_shells
      lc.create(ns)
      bf.create(ns)
      ex.create(ns)
      cc.create(ns)
      .get_lc_bf_ex_cc(lc,bf,ex,cc)

      ! Table headings
      table.create(4)
      table(1).set_heading("-L-")
      table(1).set_center(TRUE)
      table(2).set_heading("Fn")
      table(2).set_subhead("#")
      table(3).set_heading("Exponent")
      table(3).set_subheading("/au")
      table(4).set_heading("Contraction")
      table(4).set_subheading("/au")

      ! Set table column data
      table(1).set_values(lc)
      table(2).set_values(bf)
      table(3).set_values(ex)
      table(4).set_values(cc)

      ! Make the table
      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      cc.destroy
      ex.destroy
      bf.destroy
      lc.destroy

   end

end
