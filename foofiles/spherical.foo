!-------------------------------------------------------------------------------
!
! SPHERICAL: 
!
! This module contians method for the calculation of spherical harmonics,
! and associated utility methods utilising them for shape description and
! reconstruction. 
! 
! Not all methods here are *specific* to spherical harmonics, but
! because of their (sometimes) mutial dependence they have been placed
! here.
! 
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: lebedev.foo 3648 2012-02-21 01:19:03Z dylan_ $
!-------------------------------------------------------------------------------

module SPHERICAL

       implicit none

contains

! =========================
! Create and destroy object
! =========================

    create ::: leaky
    ! Create an object
        self :: PTR
        .set_defaults
    end

    destroy ::: leaky
    ! Destroy an object
        self :: PTR
        .n_points = 0
    end

    set_defaults
        self :: PTR
        .n_points = 0
    end

! =====================
! Methods to be called 
! =====================

    clebsch_gordon_coefficient(l1, m1, l2, m2, l, m) result (retval) ::: recursive, pure
        self :: IN
        l1, l2, m1, m2, l, m :: INT, IN
        retval :: REAL
        base_case, one_case, a, b, c, d, e :: BIN
        inv, left, right :: REAL

        a = (m == (m1 + m2))
        b = ((abs(l1 - l2) <= l) AND (l <= (l1 + l2)))
        c = ((-l1 <= m1) AND (m1 <= l1))
        d = ((-l2 <= m2) AND (m2 <= l2))
        e = ((-l <= m) AND (m <= l))

        one_case = (((l1 == m1) AND (m1 == 0)) AND ((l2 == l) AND (m2 == m)))

        base_case = ((l1 == l2) AND (m1 == -m2) AND (l == m) AND m == 0)

        if (a AND b AND c AND d AND e) then
            ! DO STUFF
            ! the recurrence relation is as follows:
            ! sqrt(l(l+1) - m(m - 1)) * <l1, m1, l2, m2|l, m> =
            ! sqrt(l1(l1 + 1) - m1(m1 - 1)) * <l1, m1 - 1, l2, m2|l, m - 1>
            ! + sqrt(l2(l2+1) - m2(m2 - 1)) * <l1, m1, l2, m2 - 2|l, m - 1>
            if (one_case) then
                retval = 1.0
            else if (base_case) then
                retval = ((-1)**(l1 - m1)) / (sqrt(2.0*l1 + 1.0))
            else
                left = sqrt(1.0*(l1*(l1 + 1) - m1*(m1 - 1)))
                right = sqrt(1.0*(l2*(l2 + 1) - m2*(m2 - 1)))
                inv = ONE/(sqrt(1.0*(l*(l + 1) - m*(m - 1))))
                retval = inv * (left * .clebsch_gordon_coefficient(l1, m1 - 1, l2, m2, l, m - 1) + &
                   right * .clebsch_gordon_coefficient(l1, m1, l2, m2 - 1, l, m - 1))
            end
        else
            retval = 0.0
        end
    end


    ! Taken from appendix 1 in Burel & Henocq 1995
    z_harmonic(l, m, theta) result (res) ::: recursive
        self :: IN
        l, m :: INT, IN
        theta :: REAL, IN
        res :: REAL
        fac, tmp1, tmp2 :: REAL


        if (m > l AND NOT m == 0) then
            res = 0.0
        else if ( l < 0) then
            res = .z_harmonic(abs(l) -1, m, theta)
        else if (l == m) then
            fac = INT:factorial(l)
            res = ((-0.5) ** l) / (ONE * fac)
            res = (sin(theta) ** l) * res * sqrt(ONE * INT:factorial(2*l + 1)/(4*PI))
        else if (m < 0) then
            res = ((-ONE) ** m) * .z_harmonic(l, -m, theta)
        else
            ! TMP1 and TMP2 have been checked and are working correctly
            tmp1 = sqrt(((2.0*l - 1)*(2.0*l + 1)) / ((l + m )*(l - m)))
            tmp2 = sqrt((ONE * (l + m - 1) * (l - m - 1)) / ((2*l -1)*(2*l - 3)))
            res = tmp1 * (cos(theta) * .z_harmonic(l - 1, m, theta) - tmp2 * .z_harmonic(l - 2, m, theta))
        end

    end

    y_harmonic(l, m, theta, phi) result (res)
        self :: IN
        l, m :: INT, IN
        theta, phi :: REAL, IN
        res :: CPX

        j :: CPX
        j = cmplx(0, 1)
        res = .z_harmonic(l, m, theta) * exp(j * m * phi)
    end


    get_surface_decomposition(coefficients, l_max, n_points, surface) result (mean_radius) ::: leaky
        self :: IN
        coefficients :: VEC{CPX}*, INOUT
        surface :: MAT{REAL}*, IN
        l_max :: INT, IN
        n_points :: INT, IN
        mean_radius :: REAL

        !!5810 points for best precision
        spherical_points, iso_points, iso_points_spherical :: MAT{REAL}*
        centre, p, tmp_point :: VEC{REAL}(3)
        n_pt, L, M, N, X, lm :: INT
        lebedev :: LEBEDEV*
        fvals, radii :: VEC{REAL}*
        minimum_dist, tmp, theta, phi :: REAL
        val :: CPX

        X = (l_max + 1)**2
        n_pt = surface.dim1
        ! shift surface to be about origin
        ! create structures
        iso_points.create(n_pt, 3)
        radii.create(n_pt)
        fvals.create(n_points)
        coefficients.create(X)
        lebedev.create
        

        iso_points = surface
        centre(1) = sum(iso_points(:,1)) / n_pt
        centre(2) = sum(iso_points(:,2)) / n_pt
        centre(3) = sum(iso_points(:,3)) / n_pt

        do N = 1, n_pt
            iso_points(N,:) = (iso_points(N,:) - centre)
            radii(N) = iso_points(N,:).norm
        end

        mean_radius = sum(radii) /n_pt

        do N = 1,n_pt
            p = iso_points(N,:)
            iso_points(N,:) = p / mean_radius
            radii(N) = p.norm/mean_radius
        end

        lebedev.set_n_points(n_points)
        fvals = ONE

        .cart2sph(lebedev.point, spherical_points)
        .cart2sph(iso_points, iso_points_spherical)
        do N = 1, n_points
            minimum_dist= 100000000
            p = lebedev.point(N,:)
            do X = 1, n_pt
                tmp_point = iso_points(X,:)
                tmp_point.normalise
                tmp = ((tmp_point(2)- p(2))**2 + (tmp_point(3) - p(3))**2 + (tmp_point(1)-p(1))**2)
                if (tmp < minimum_dist) then
                    fvals(N) = iso_points_spherical(X,1)
                    minimum_dist = tmp
                end
            end
            ENSURE(NOT minimum_dist >= 100000000, "Couldn't find any point even close???")
        end
        ! coefficients are indexed as follows: {c00,c1-1,c10,c11,c2-2,c2-1,c20,c21,c22... etc.}
        lm = 1
        do L = 0, l_max
            do M = -L, L
                val = cmplx(0, 0)
                do N = 0, n_points
                    theta = spherical_points(N,2)
                    phi = spherical_points(N,3)
                    ! theta and phi have been checked and make sense
                    val = val + lebedev.weight(N) * fvals(N) * conjg(.y_harmonic(l,m,theta, phi))
                end
                coefficients(lm) = val
                lm = lm + 1
            end
        end
        print *, "lm = ", lm

    end

    reconstruct_shape(coefficients, points, l_max) ::: leaky

        self :: IN
        coefficients :: VEC{CPX}*, IN
        points :: MAT{REAL}*, INOUT
        l_max :: INT, IN

        X, N, a, L, lm, J :: INT
        phi, theta :: REAL

        c, y :: CPX

        points.create(91*181, 3)
        X = 0
        do N = 0, 90
            theta = N * PI/90
            do a = 0, 180
                x = x + 1
                phi = a * PI/90
                lm = 1
                c = 0
                do L = 0, l_max
                    do J = -L, L
                        y = .y_harmonic(L,J,theta,phi)
                        c = c + (y * coefficients(lm))
                        lm = lm + 1
                    end
                end
                points(X,1) = abs(c) * sin(theta) * sin(phi)
                points(X,2) = abs(c) * sin(theta) * cos(phi)
                points(X,3) = abs(c) * cos(theta)
            end
        end
    end

    ! MIGHT NOT BE WORKING
    pi_tensor(l1, l2, l, m, coefficients) result(sigma) ::: pure

        self :: IN
        l1, l2, l, m :: INT, IN
        coefficients :: VEC{CPX}*
        sigma :: CPX
        m1, m2 :: INT
        cg :: REAL
        cl1m1, cl2mm1 :: CPX
        ! coefficients(l,m) is indexed by l**2 + l + 1 + m
        sigma = 0.0
        do m1 = -l1, l1
            cg = .clebsch_gordon_coefficient(l1, m1, l2, m - m1, l, m)
            cl1m1 = coefficients((l1)**2 + l1 + m1 + 1)
            cl2mm1 = coefficients((l2)**2 + l2 + (m - m1) + 1)
            sigma = sigma + cg * cl1m1 * cl2mm1
        end
    end

    make_invariants(coefficients, l_max, invariants) ::: leaky
        self :: IN
        coefficients :: VEC{CPX}*, IN
        l_max :: INT, IN
        invariants :: VEC{REAL}*, INOUT

        lm, L, M, l1, l2, l3, l4 :: INT
        cond1, cond2, cond3, cond4, cond5 :: BIN
        sigma, cg :: REAL
        c, pt :: CPX
        invariants.create(l_max+1)
        
        ! N-Invariants
        lm = 1
        do L = 0, l_max
            sigma = 0.0
            do M = -L, L
                c = coefficients(lm)
                c = c * conjg(c)
                sigma = sigma + abs(c)
                lm = lm + 1
            end
            invariants(L+1) = sqrt(sigma)
        end

        ! P-Invariants
        !do L = 0, l_max
        !    do l1 = 1, L
        !        do l2 = 1,l1
        !        cond1 = (1 <= l2 AND l2 <= l1 AND l1 <= l)
        !        cond2 = (l1 - l2) <= l AND l <= (l1 + l2)
        !        cond3 = (NOT (l2 == l1 )) OR (mod(l, 2) == 0)
        !        cond4 = (NOT (l1 == l)) OR (mod(l2, 2) == 0)
        !        if (cond1 AND cond2 AND cond3 AND cond4) then
        !            sigma = 0.0
        !            do M = -L, L
        !                c = conjg(coefficients(l**2 + l + m + 1))
        !                pt = .pi_tensor(l1, l2, l, m, coefficients)
        !                sigma = sigma + abs(pt * c)
        !            end
        !            print *, "Appending to invariants l = ",l, "l1 = ",l1,"l2= ",l2,"value =", sigma
        !            invariants.append(sigma)
        !        end
!
!                end
!            end
!        end

        ! Q-Invariants
!        do L = 0, l_max
!        end
    end

    cart2sph(cart_points, spherical_points) ::: leaky
        ! expects an N x 3 array and will create spherical_points as N x 3
        cart_points :: MAT{REAL}*, IN
        spherical_points :: MAT{REAL}*, OUT

        N :: INT
        x, y, z :: REAL
        r, theta, phi :: REAL
        spherical_points.create(cart_points.dim1, 3)

        do N = 1, cart_points.dim1
            x = cart_points(N, 1) 
            y = cart_points(N, 2)
            z = cart_points(N, 3)
            r = sqrt(x**2 + y**2 + z**2)
            theta = acos(z / r)
            phi = atan(y, x)
            spherical_points(N, 1) = r
            spherical_points(N, 2) = theta
            spherical_points(N, 3) = phi
        end

    end

! end of module
end
