!-------------------------------------------------------------------------------
!
! SPHERICAL: 
!
! This module contians method for the calculation of spherical harmonics,
! and associated utility methods utilising them for shape description and
! reconstruction. 
! 
! Not all methods here are *specific* to spherical harmonics, but
! because of their (sometimes) mutial dependence they have been placed
! here.
! 
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: lebedev.foo 3648 2012-02-21 01:19:03Z dylan_ $
!-------------------------------------------------------------------------------

module SPHERICAL

       implicit none

contains

! =========================
! Create and destroy object
! =========================

    create ::: leaky
    ! Create an object
        self :: PTR
        
        allocate(self)
        ADD_MEMORY(SELF_TYPE_SIZE)

        .nullify_ptr_part

        .factorials.create(0,70)
        .set_defaults
    end

    destroy ::: leaky
    ! Destroy an object
        self :: PTR

        if (.destroyed) return
        .destroy_ptr_part

        DELETE_MEMORY(SELF_TYPE_SIZE)
        deallocate(self)
    end

    set_defaults
        self :: PTR
        N :: INT
        .n_points = 0
        .nfact = 70 ! the highest number we have a factorial stored for

        .recur = FALSE

        .factorials(0) = 1
        .factorials(1) = 1
        do N = 2,.nfact
            .factorials(N) = .factorials(N - 1) * N
        end
    end

    nullify_ptr_part
        nullify(.factorials)
    end

    destroy_ptr_part
        .factorials.destroy
    end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

! =====================
! Methods to be called 
! =====================

    
    ! Calculate the clebsch-gordan coefficient
    ! using explicit racah formula (if the factorial is not too big)
    ! but fail using the recurrence relation etc. if fac is too big
    ! recur is a flag to test whether or not the factorials
    ! used in clebsch were too large. Note that this is NOT thread
    ! safe or parellisable using this object for future reference
    clebsch_gordan(j1, m1, j2, m2, j, m) result (res) 
        j, m, j1, j2, m1, m2 :: INT
        res :: REAL
        .recur = FALSE
        if (j1 == j2 AND m1 == - m2 AND j == 0 AND m == 0) then
            res = (-ONE) ** (j - m) / sqrt(TWO *j + 1)
        else if (j1  == m1 AND m1 == 0 AND j2 == j AND m2 == m) then
            res = ONE
        else
            res = .clebsch(j1 *2, m1 *2, j2 * 2, m2 * 2, j * 2, m * 2)
            if (.recur) then
                res = .clebsch_rec(j1, m1, j2, m2, j, m)
            end
        end
    end

    
    clebsch(j1, m1, j2, m2, j, m) result (res) 
    ! Calculation using Racah formula taken from "Angular Momentum",
    ! D.M.Brink & G.R.Satchler, Oxford, 1968

        j1, m1, j2, m2, j, m :: INT
        res :: REAL

        j1nm1, jnj2pm1, j2pm2, jnj1nm2, j1pj2nj :: INT
        k, mink, maxk :: INT
        iphase :: INT
        tmp :: REAL
        a, b, c, d, e, f :: BIN


        res = ZERO

        a = abs(m1) > j1
        b = abs(m2) > j2
        c = abs(m) > j
        d = j1 < 0 OR j2 < 0 OR j < 0
        e = abs(j1 - j2) > j
        f = j > j1 + j2

        if ( a OR b OR c OR d OR e OR f OR (NOT ((m1 + m2) == M))) return

        j1nm1 = (j1 - m1)/2
        jnj2pm1 = (j - j2 + m1)/2
        j2pm2 = (j2 + m2)/2
        jnj1nm2 = (j - j1 - m2)/2
        j1pj2nj = (j1 + j2 - j)/2

        ! check if evenness is valid i.e. j1 and m1 both even/odd
        a = (j1nm1 * 2 == j1 - m1)
        b = (j2pm2 * 2 == j2 + m2)
        c = (j1pj2nj * 2 == j1 + j2 - j)

        if (NOT (a AND b AND c)) then
            return
        end
        mink = max(max(-jnj2pm1, -jnj1nm2), 0)
        maxk = min(min(j1nm1, j2pm2), j1pj2nj)

        if (NOT ((mink/2)*2 == mink)) then
            iphase = -1
        else
            iphase = 1
        end
    
        do k = mink, maxk
            tmp =  (.fac(j1nm1 - k) * .fac(jnj2pm1 + k) * .fac(j2pm2 - k) &
                    * .fac(jnj1nm2 + k) * .fac(k) * .fac(j1pj2nj - k))
            res = res + iphase/tmp
            iphase = - iphase
        end

        if (mink > maxk) then
            res = ONE
        end

        tmp = sqrt(ONE * .fac(j1pj2nj))
        tmp = tmp * sqrt(.fac((j1 + j - j2) / 2)) 
        tmp = tmp * sqrt(.fac((j2 + j - j1)/2)) 
        tmp = tmp / sqrt(.fac((j1 + j2 + j)/2 + 1))
        tmp = tmp * sqrt(ONE * (j + 1))
        tmp = tmp * sqrt(.fac((j1 + m1)/2))
        tmp = tmp * sqrt(.fac(j1nm1))
        tmp = tmp * sqrt(.fac(j2pm2))
        tmp = tmp * sqrt(.fac((j2 - m2)/2))
        tmp = tmp * sqrt(.fac((j + m)/2))
        tmp = tmp * sqrt(.fac((j - m)/2))

        res = res * tmp

        return
    end

    
    ! recursion relations
    clebsch_rec(l1, m1, l2, m2, l, m) result (retval) ::: recursive
        self :: IN
        l1, l2, m1, m2, l, m :: INT, IN
        retval :: REAL
        base_case, one_case, a, b, c, d, e :: BIN
        inv, left, right :: REAL

        a = (m == (m1 + m2))
        b = ((abs(l1 - l2) <= l) AND (l <= (l1 + l2)))
        c = ((-l1 <= m1) AND (m1 <= l1))
        d = ((-l2 <= m2) AND (m2 <= l2))
        e = ((-l <= m) AND (m <= l))

        one_case = (((l1 == m1) AND (m1 == 0)) AND ((l2 == l) AND (m2 == m)))
        base_case = ((l1 == l2) AND (m1 == -m2) AND (l == m) AND m == 0)

        if (a AND b AND c AND d AND e) then
        ! DO STUFF
        ! the recurrence relation is as follows:
        ! sqrt(l(l+1) - m(m - 1)) * <l1, m1, l2, m2|l, m> =
        ! sqrt(l1(l1 + 1) - m1(m1 - 1)) * <l1, m1 - 1, l2, m2|l, m - 1>
        ! + sqrt(l2(l2+1) - m2(m2 - 1)) * <l1, m1, l2, m2 - 2|l, m - 1>
        if (one_case) then
            retval = 1.0
        else if (base_case) then
            retval = ((-1)**(l1 - m1)) / (sqrt(2.0*l1 + 1.0))
        else
            left = sqrt(1.0*(l1*(l1 + 1) - m1*(m1 - 1)))
            right = sqrt(1.0*(l2*(l2 + 1) - m2*(m2 - 1)))
            inv = ONE/(sqrt(1.0*(l*(l + 1) - m*(m - 1))))
            retval = inv * (left * .clebsch_rec(l1, m1 - 1, l2, m2, l, m - 1) + &
            right * .clebsch_rec(l1, m1, l2, m2 - 1, l, m - 1))
        end
        else
            retval = 0.0
        end
    end


    fac(l) result (res) 
        l :: INT, IN
        res :: REAL

        ENSURE(.factorials.created, "Factorials array not created?")

        res = ONE
        if (l <= 1) return

        if (l > 70) then
            WARN("Factorials above 70! are not supported")
            .recur = TRUE
            return
        end

        res = .factorials(l)
    end


    ! Kronecker delta function for INT type
    kronecker(a, b) result(res) ::: pure, selfless
        a, b :: INT, IN
        res :: INT
        if (a == b) then
            res = 1
        else
            res = 0
        end
    end


    ! Taken from appendix 1 in Burel & Henocq 1995
    z_harmonic(l, m, theta) result (res) ::: recursive
        self :: IN
        l, m :: INT, IN
        theta :: REAL, IN
        res :: REAL
        fac, tmp1, tmp2 :: REAL


        if (m > l AND NOT m == 0) then
            res = 0.0

        else if ( l < 0) then
            res = .z_harmonic(abs(l) -1, m, theta)

        else if (l == m) then
            fac = INT:factorial(l)
            res = ((-0.5) ** l) / (ONE * fac)
            res = (sin(theta) ** l) * res &
                  * sqrt(ONE * INT:factorial(2*l + 1)/(4*PI))

        else if (m < 0) then
            res = ((-ONE) ** m) * .z_harmonic(l, -m, theta)

        else
            ! TMP1 and TMP2 have been checked and are working correctly
            tmp1 = sqrt(((2.0*l - 1)*(2.0*l + 1)) / ((l + m )*(l - m)))
            tmp2 = sqrt((ONE * (l + m - 1) &
                   * (l - m - 1)) / ((2*l -1)*(2*l - 3)))
            res = tmp1 * (cos(theta) * .z_harmonic(l - 1, m, theta) &
                       - tmp2 * .z_harmonic(l - 2, m, theta))
        end

    end

    y_harmonic(l, m, theta, phi) result (res)
        self :: IN
        l, m :: INT, IN
        theta, phi :: REAL, IN
        res :: CPX

        j :: CPX
        j = cmplx(0, 1)
        res = .z_harmonic(l, m, theta) * exp(j * m * phi)
    end


    get_surface_decomposition(coefficients, l_max, n_points, surface) result (mean_radius) ::: leaky
        self :: IN
        coefficients :: VEC{CPX}*, INOUT
        surface :: MAT{REAL}*, IN
        l_max :: INT, IN
        n_points :: INT, IN
        mean_radius :: REAL

        !!5810 points for best precision
        spherical_points, iso_points, iso_points_spherical :: MAT{REAL}*
        centre, p, tmp_point :: VEC{REAL}(3)
        n_pt, L, M, N, X, lm :: INT
        lebedev :: LEBEDEV*
        fvals, radii :: VEC{REAL}*
        minimum_dist, tmp, theta, phi :: REAL
        val :: CPX

        X = (l_max + 1)**2
        n_pt = surface.dim1
        ! shift surface to be about origin
        ! create structures
        iso_points.create(n_pt, 3)
        radii.create(n_pt)
        fvals.create(n_points)
        coefficients.create(X)
        lebedev.create
        

        iso_points = surface
        centre(1) = sum(iso_points(:,1)) / n_pt
        centre(2) = sum(iso_points(:,2)) / n_pt
        centre(3) = sum(iso_points(:,3)) / n_pt

        do N = 1, n_pt
            iso_points(N,:) = (iso_points(N,:) - centre)
            radii(N) = iso_points(N,:).norm
        end

        mean_radius = sum(radii) /n_pt

        do N = 1,n_pt
            p = iso_points(N,:)
            iso_points(N,:) = p / mean_radius
            radii(N) = p.norm/mean_radius
        end

        lebedev.set_n_points(n_points)
        fvals = ONE

        SPHERICAL:cart2sph(lebedev.point, spherical_points)
        SPHERICAL:cart2sph(iso_points, iso_points_spherical)
        do N = 1, n_points
            minimum_dist= 100000000
            p = lebedev.point(N,:)
            do X = 1, n_pt
                tmp_point = iso_points(X,:)
                tmp_point.normalise
                tmp = ((tmp_point(2)- p(2))**2 + (tmp_point(3) - p(3))**2 + (tmp_point(1)-p(1))**2)
                if (tmp < minimum_dist) then
                    fvals(N) = iso_points_spherical(X,1)
                    minimum_dist = tmp
                end
            end
            ! Hacky test to see if we've got something sensible
            ENSURE(NOT minimum_dist >= 100000000, "Couldn't find any point even close???")
        end
        ! coefficients are indexed as follows: {c00,c1-1,c10,c11,c2-2,c2-1,c20,c21,c22... etc.}
        lm = 1
        do L = 0, l_max
            do M = -L, L
                val = cmplx(0, 0)
                do N = 0, n_points
                    theta = spherical_points(N,2)
                    phi = spherical_points(N,3)
                    ! theta and phi have been checked and make sense
                    val = val + lebedev.weight(N) * fvals(N) * conjg(.y_harmonic(l,m,theta, phi))
                end
                coefficients(lm) = val
                lm = lm + 1
            end
        end
        print *, "Number of coefficients used: ", lm

    end

    reconstruct_shape(coefficients, points, l_max) ::: leaky

        self :: IN
        coefficients :: VEC{CPX}*, IN
        points :: MAT{REAL}*, INOUT
        l_max :: INT, IN

        X, N, a, L, lm, J :: INT
        phi, theta :: REAL

        c, y :: CPX

        points.create(91*181, 3)
        X = 0
        do N = 0, 90
            theta = N * PI/90
            do a = 0, 180
                x = x + 1
                phi = a * PI/90
                lm = 1
                c = 0
                do L = 0, l_max
                    do J = -L, L
                        y = .y_harmonic(L,J,theta,phi)
                        c = c + (y * coefficients(lm))
                        lm = lm + 1
                    end
                end
                points(X,1) = abs(c) * sin(theta) * sin(phi)
                points(X,2) = abs(c) * sin(theta) * cos(phi)
                points(X,3) = abs(c) * cos(theta)
            end
        end
    end

    ! Implementation of the so called 'Pi tensor', providing
    pi_tensor(l1, l2, l, m, coefficients) result(sigma) 
        self :: IN
        l1, l2, l, m :: INT, IN
        coefficients :: VEC{CPX}*
        sigma :: CPX
        m1, m2, ref :: INT
        cg :: REAL
        c1, c2 :: CPX

        sigma = cmplx(0.0,0.0)

        do m1 = -l1, l1
            do m2 = -l2, l2
                cg = .clebsch_gordan(l1, m1, l2, m2, l, m)
                ref = ((l1)**2 + l1 + m1 + 1)
                c1 = coefficients(ref)
                ref = (l2)**2 + l2 + m2 + 1
                c2 = coefficients(ref)
                sigma = sigma + cg * c1 * c2
            end
        end
    end

    make_invariants(coefficients, l_max, invariants) ::: leaky
        self :: IN
        coefficients :: VEC{CPX}*, IN
        l_max :: INT, IN
        invariants :: VEC{REAL}*, INOUT

        lm, L, M, l1, l2, l3, l4 :: INT
        cond1, cond2, cond3, cond4 :: BIN
        num, invnum :: INT
        sigma :: REAL
        psigma, c, pt :: CPX
        invariants.create(150)
        
        lm = 1
        ! keeping track of the number of N, P or Q invariants
        num = 0
        ! keeping track of the total number of invariants
        invnum = 1

        ! N-Invariants
        do L = 0, l_max
            if (num >= 10) then
                exit
            end
            sigma = 0.0
            do M = -L, L
                c = coefficients(lm)
                c = c * conjg(c)
                sigma = sigma + abs(c)
                lm = lm + 1
            end
            invariants(invnum) = sqrt(sigma)
            num = num + 1
            invnum = invnum +1
        end
        
        ! P-Invariants, taken from Burel & Henocq
        num = 0
        do l = 1, l_max
            do l1 = 1, l
                do l2 = 1,l1
                cond2 = (l1 - l2) <= l AND l <= (l1 + l2)
                cond3 = (NOT (l2 == l1 )) OR (mod(l, 2) == 0)
                cond4 = (NOT (l1 == l)) OR (mod(l2, 2) == 0)
                if (cond2 AND cond3 AND cond4) then
                    if (num >= 80) then
                        exit
                    end
                    psigma = cmplx(0.0,0.0)
                    do M = -l, l
                        c = conjg(coefficients(l**2 + l + m + 1))
                        pt = .pi_tensor(l1, l2, l, m, coefficients)
                        psigma = psigma + (pt * c)
                    end
                    if (mod(l + l1 + l2, 2) == 0) then
                        invariants(invnum) = real(psigma)
                    else
                        invariants(invnum) = (aimag(psigma))
                    end
                    num = num + 1
                    invnum = invnum + 1
                end

                end
            end
        end

        ! Q-Invariants, taken from Burel & Henocq
        num = 0
        do l = 1, l_max
            do l1 = 0, l_max
                do l2 = 0, l1
                do l3 = 0, l1
                do l4 = 0, l3
                    cond1 = (NOT (l1 == l2)) OR (mod(l,2) == 0)
                    cond2 = ((l1 - l2) <= l) AND (l <=(l1 + l2))
                    cond3 = ((l3 - l4) <= l) AND (l <= (l3 + l4))
                    cond4 = (NOT (l4 == l3) OR (mod(l,2) == 0))
                    if (cond1 AND cond2 AND cond3 AND cond4) then
                        if (num >= 60) then
                            exit
                        end
                        psigma = cmplx(0.0,0.0)
                        do M = -l, l
                            c = conjg(.pi_tensor(l3, l4, l, m, coefficients))
                            pt = .pi_tensor(l1, l2, l, m, coefficients)
                            psigma = psigma + (pt * c)
                        end
                        ! EVEN -> REAL, ODD -> CPX
                        if (mod(l1 + l2 + l3 + l4, 2) == 0) then
                            invariants(invnum) = (real(psigma))
                        else
                            invariants(invnum) = (aimag(psigma))
                        end
                        num = num + 1
                        invnum = invnum + 1
                        
                    end
                end
                end
                end
            end
        end
    end


    cart2sph(cart_points, spherical_points) ::: leaky, selfless
        ! expects an N x 3 array and will create spherical_points as N x 3
        cart_points :: MAT{REAL}*, IN
        spherical_points :: MAT{REAL}*, OUT

        N :: INT
        x, y, z :: REAL
        r, theta, phi :: REAL

        spherical_points.create(cart_points.dim1, 3)

        do N = 1, cart_points.dim1
            x = cart_points(N, 1) 
            y = cart_points(N, 2)
            z = cart_points(N, 3)
            r = sqrt(x**2 + y**2 + z**2)
            theta = acos(z / r)
            phi = atan(y, x)
            spherical_points(N, 1) = r
            spherical_points(N, 2) = theta
            spherical_points(N, 3) = phi
        end

    end

    ! wigner3j calculated from clebsch_gordan through the symmetry relation:
    ! |j1 j2 j3|
    ! |        | == ((-1)^(j1 -j2 - m3))/sqrt(2*j3 + 1) * cg(j1,m1,j2,m2,j3,-m3)
    ! |m1 m2 m3|
    ! the triangle inequalities should hold for both
    ! 
    wigner3j(j1, m1, j2, m2, j3, m3) result(res)
        j1, j2, j3, m1, m2, m3 :: INT, IN
        res :: REAL
        cg, tmp :: REAL

        tmp = (-1)**(j1 - j2 - m3) / sqrt(TWO*j3 + 1)
        cg = .clebsch_gordan(j1, m1, j2, m2, j3, -m3)
        res = tmp * cg

    end

! end of module
end
