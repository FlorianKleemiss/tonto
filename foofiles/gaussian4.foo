!---------------------------------------------------------------------------
!
!  GAUSSIAN4 : Quartets of gaussian functions
!
! Copyright (C) Dylan Jayatilaka, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: gaussian4.foo 3809 2012-10-25 06:59:50Z dylan_ $
!
!---------------------------------------------------------------------------

module GAUSSIAN4

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   created result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has *not* been created
   end

!  =====
!  ERI's
!  =====

   make_ERI_ints(I)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      self :: IN
      I :: MAT4{REAL}, OUT

      rys :: RYS*
      Ix,Iy,Iz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      ! Angular momenta and # of roots
      l_e = .a.l + .b.l
      l_f = .c.l + .d.l
      n_roots = (l_e+l_f)/2 + 2

      ! Allocate 2D integrals
      Ix.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)
      Iy.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)
      Iz.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)

      ! Gaussian index arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      ! Exponents
      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      ! Positions
      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P

      ! Rys roots
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! Form the 2D integrals
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD)

      ! Form the integrals
      I = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)

      ! Cleanup
      rys.destroy
      Iz.destroy
      Iy.destroy
      Ix.destroy

      ! Prefactor
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)
      I   = fac*I

   end

   transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b,max_d) ::: pure, private
   ! Use the transfer relation to put momenta on centers B and D to get all
   ! the 2d integrals "Ix", "Iy" and "Iz". If present, "max_b" and "max_d"
   ! are the maximum l-values desired for centers b and d, respectively.
   ! You must ensure that the "Ii" arrays are big enough, in this case.
      self :: IN
      Ix,Iy,Iz :: MAT5{REAL}, INOUT
      AB,CD :: VEC{REAL}(3), IN
      max_b,max_d :: INT, IN, optional

      le1,lf1,l_a,l_b,l_c,l_d,a,b,c,d,a1,b1,c1,d1,la1 :: INT

      l_a = .a.l
      l_b = .b.l
      l_c = .c.l
      l_d = .d.l

      if (present(max_b)) l_b = max_b
      if (present(max_d)) l_d = max_d

      if (l_b==0 AND l_d==0) return

      if (l_b/=0) then
         le1 = l_a + l_b + 1
         do b = 1,l_b
         do a = 1,le1 - b
            b1 = b + 1
            a1 = a + 1
            Ix(:,a,b1,:,1) = Ix(:,a1,b,:,1) + AB(1)*Ix(:,a,b,:,1)
            Iy(:,a,b1,:,1) = Iy(:,a1,b,:,1) + AB(2)*Iy(:,a,b,:,1)
            Iz(:,a,b1,:,1) = Iz(:,a1,b,:,1) + AB(3)*Iz(:,a,b,:,1)
         end
         end
      end

      if (l_d/=0) then
         la1 = l_a + l_b - .b.l + 1 ! increase more along a as for b
         lf1 = l_c + l_d + 1
         do d = 1,l_d
         do c = 1,lf1 - d
            d1 = d + 1
            c1 = c + 1
            Ix(:,1:la1,:,c,d1) = Ix(:,1:la1,:,c1,d) + CD(1)*Ix(:,1:la1,:,c,d)
            Iy(:,1:la1,:,c,d1) = Iy(:,1:la1,:,c1,d) + CD(2)*Iy(:,1:la1,:,c,d)
            Iz(:,1:la1,:,c,d1) = Iz(:,1:la1,:,c1,d) + CD(3)*Iz(:,1:la1,:,c,d)
         end
         end
      end

   end

   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,einv,PA,QC,QP,max_e,max_f) ::: pure
   ! Forms the two dimensional integrals "Ix", "Iy" and "Iz" with momenta only
   ! on centers A and C, using Rys roots "t2" and weights "wt".
   ! Other variables are intermediates, to avoid calculations: see make_ERI_ints.
   ! If present, "max_e" and "max_f" are used for the maximum angular momenta
   ! of centers (a+b) and (c+d) respectively -- for derivative integrals.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, INOUT
      t2,wt :: VEC{REAL}, IN
      rho,zinv,einv :: REAL, IN
      PA,QC,QP :: VEC{REAL}(3), IN
      max_e,max_f :: INT, IN, optional

      ret,rzt,ce,cf,bb,ce1,cf1 :: VEC{REAL}(size(t2))
      l_e,l_f,e,f,em1,fm1,fp1,ep1,k :: INT

      l_e = .a.l + .b.l
      if (present(max_e)) l_e = max_e

      l_f = .c.l + .d.l
      if (present(max_f)) l_f = max_f

      Ix(:,1,1) = ONE
      Iy(:,1,1) = ONE
      Iz(:,1,1) = ONE

      if (l_e/=0 OR l_f/=0) then

       if (l_f>0) then

         ret = rho*t2*einv
         Ix(:,1,2) = QC(1) - ret(:)*QP(1)
         Iy(:,1,2) = QC(2) - ret(:)*QP(2)
         Iz(:,1,2) = QC(3) - ret(:)*QP(3)

         if (l_f>1) then
           cf = (ONE - ret) * HALF * einv
           do f = 2,l_f
             fm1 = f - 1
             fp1 = f + 1
             cf1 = fm1 * cf
             Ix(:,1,fp1) = Ix(:,1,2)*Ix(:,1,f) + cf1*Ix(:,1,fm1)
             Iy(:,1,fp1) = Iy(:,1,2)*Iy(:,1,f) + cf1*Iy(:,1,fm1)
             Iz(:,1,fp1) = Iz(:,1,2)*Iz(:,1,f) + cf1*Iz(:,1,fm1)
           end
         end

       end

       if (l_e>0) then

         rzt = rho*t2*zinv
         Ix(:,2,1) = PA(1) + rzt(:)*QP(1)
         Iy(:,2,1) = PA(2) + rzt(:)*QP(2)
         Iz(:,2,1) = PA(3) + rzt(:)*QP(3)

         if (l_e>1) then
           ce = (ONE - rzt) * HALF * zinv
           do e = 2,l_e
             em1 = e - 1
             ep1 = e + 1
             ce1 = em1 * ce
             Ix(:,ep1,1) = Ix(:,2,1)*Ix(:,e,1) + ce1*Ix(:,em1,1)
             Iy(:,ep1,1) = Iy(:,2,1)*Iy(:,e,1) + ce1*Iy(:,em1,1)
             Iz(:,ep1,1) = Iz(:,2,1)*Iz(:,e,1) + ce1*Iz(:,em1,1)
           end
         end

       end

       if (l_f>0 AND l_e>0) then

         bb = HALF*einv*rzt
         Ix(:,2,2) = Ix(:,1,2)*Ix(:,2,1)+bb
         Iy(:,2,2) = Iy(:,1,2)*Iy(:,2,1)+bb
         Iz(:,2,2) = Iz(:,1,2)*Iz(:,2,1)+bb

         do f= 2,l_f
           fm1 = f - 1
           fp1 = f + 1
           cf1 = fm1 * cf
           Ix(:,2,fp1) = Ix(:,1,2)*Ix(:,2,f) + cf1*Ix(:,2,fm1) + bb*Ix(:,1,f)
           Iy(:,2,fp1) = Iy(:,1,2)*Iy(:,2,f) + cf1*Iy(:,2,fm1) + bb*Iy(:,1,f)
           Iz(:,2,fp1) = Iz(:,1,2)*Iz(:,2,f) + cf1*Iz(:,2,fm1) + bb*Iz(:,1,f)
         end

         do e = 2,l_e
           em1 = e - 1
           ep1 = e + 1
           ce1 = em1 * ce
           do f = 2,l_f+1
             fm1 = f - 1
             Ix(:,ep1,f) = Ix(:,2,1)*Ix(:,e,f) + ce1*Ix(:,em1,f) + fm1*bb(:)*Ix(:,e,fm1)
             Iy(:,ep1,f) = Iy(:,2,1)*Iy(:,e,f) + ce1*Iy(:,em1,f) + fm1*bb(:)*Iy(:,e,fm1)
             Iz(:,ep1,f) = Iz(:,2,1)*Iz(:,e,f) + ce1*Iz(:,em1,f) + fm1*bb(:)*Iz(:,e,fm1)
           end
         end

       end
      end

      ! Multiply Iz by the weight
      do k = 1,Iz.dim1
        Iz(k,:,:) = Iz(k,:,:)*wt(k)
      end

   end

!  ====================
!  Spin-orbit integrals
!  ====================

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the same-spin orbit integrals "Sx" "Sy" "Sz"  and the
   ! other spin orbit integrals  "Ox" "Oy" "Oz" using Rys method.
   ! Reference: Bearpark et al., Mol. Phys. 80, p. 479 (1993)
      self :: IN
      Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}, OUT

      rys :: RYS*
      Ix,Iy,Iz,LLx,LLy,LLz,RRx,RRy,RRz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1

      ! One higherfor differentiating
      l_e = .a.l + .b.l + 1
      l_f = .c.l + .d.l + 1

      n_roots = (l_e+l_f+2)/2

      Ix.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      Iy.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P

      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! 2D integrals: one unit higher for differentiating
      Ix = ZERO
      Iy = ZERO
      Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b=l_b,max_d=l_d) ! a & c will automatically be one unit higher

      ! Derivative integrals
      LLx.create(n_roots,l_a,l_b,l_c,l_d) 
      LLy.create(n_roots,l_a,l_b,l_c,l_d)
      LLz.create(n_roots,l_a,l_b,l_c,l_d)
      RRx.create(n_roots,l_a,l_b,l_c,l_d)
      RRy.create(n_roots,l_a,l_b,l_c,l_d)
      RRz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(Ix,"a",LLx); .differentiate(Iy,"a",LLy); .differentiate(Iz,"a",LLz)
      .differentiate(Ix,"b",RRx); .differentiate(Iy,"b",RRy); .differentiate(Iz,"b",RRz)

      ! Form the same-spin orbit integrals
      Sx = sum(Ix(:,ax,bx,cx,dx)* &
             (LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz) &
             -RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Sy = sum(Iy(:,ay,by,cy,dy)* &
             (LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx) &
             -RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Sz = sum(Iz(:,az,bz,cz,dz)* &
             (LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy) &
             -RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)

      .differentiate(Ix,"c",LLx); .differentiate(Iy,"c",LLy); .differentiate(Iz,"c",LLz)
      .differentiate(Ix,"d",RRx); .differentiate(Iy,"d",RRy); .differentiate(Iz,"d",RRz)

      ! Form the other spin orbit integrals
      Ox = sum(Ix(:,ax,bx,cx,dx)* &
             (LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz) &
             -RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Oy = sum(Iy(:,ay,by,cy,dy)* &
             (LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx) &
             -RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Oz = sum(Iz(:,az,bz,cz,dz)* &
             (LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy) &
             -RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)

      RRz.destroy; RRy.destroy; RRx.destroy
      LLz.destroy; LLy.destroy; LLx.destroy
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)
      Sx = fac*Sx; Sy = fac*Sy; Sz = fac*Sz
      Ox = fac*Ox; Oy = fac*Oy; Oz = fac*Oz

   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole-dipole integrals "Dij" using Rys method.
   ! Reference: None. But see Bearpark et al., Mol. Phys. 80, p. 479 (1993) for
   ! inspiration.
      Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: MAT4{REAL}, OUT

      rys :: RYS*
      Ix,Iy,Iz,Lx,Ly,Lz,Rx,Ry,Rz,LL,LR,RR :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1

      ! Two higher for differentiating A, B.
      l_e = .a.l + .b.l + 2
      l_f = .c.l + .d.l    

      n_roots = (l_e+l_f+2)/2

      ! 2D intermediate integrals
      Ix.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)  
      Iy.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P

      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! two units higher on B for differentiating
      Ix = ZERO
      Iy = ZERO
      Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b=l_b+1) ! A will automatically be 2 units higher

      ! Derivative integrals
      Lx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ly.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Lz.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Rx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ry.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Rz.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      LL.create(n_roots,l_a  ,l_b  ,l_c,l_d)
      RR.create(n_roots,l_a  ,l_b  ,l_c,l_d)
      LR.create(n_roots,l_a  ,l_b  ,l_c,l_d)

      .differentiate(Ix,"a",Lx); .differentiate(Ix,"b",Rx)
      .differentiate(Iy,"a",Ly); .differentiate(Iy,"b",Ry)
      .differentiate(Iz,"a",Lz); .differentiate(Iz,"b",Rz)
      .differentiate(Lx,"a",LL); .differentiate(Rx,"b",RR)
      .differentiate(Lx,"b",LR)
      LR = TWO*LR

      Dxx = sum(LL(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     LR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     RR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)

      .differentiate(Ly,"a",LL); .differentiate(Ry,"b",RR)
      .differentiate(Ly,"b",LR); LR = TWO*LR

      Dyy = sum(Ix(:,ax,bx,cx,dx)*LL(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*LR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*RR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)

      .differentiate(Lz,"a",LL); .differentiate(Rz,"b",RR)
      .differentiate(Lz,"b",LR); LR = TWO*LR

      Dzz = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LL(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LR(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Iz(:,ay,by,cy,dy)*RR(:,az,bz,cz,dz),dim=1)

      LR.destroy; RR.destroy; LL.destroy

      Dxy = sum(Lx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Lx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      Dxz = sum(Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)
      Dyz = sum(Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)

      Rz.destroy; Ry.destroy; Rx.destroy
      Lz.destroy; Ly.destroy; Lx.destroy
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)
      Dxx = fac*Dxx; Dyy = fac*Dyy; Dzz = fac*Dzz
      Dxy = fac*Dxy; Dxz = fac*Dxz; Dyz = fac*Dyz

   end

   differentiate(I,index,ID) ::: PURE
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *nuclear* coordinate on basis function "index", which can be
   ! "a" "b" "c" or "d" depending on which center is differntiated.
   ! Place the result in "ID".
      self :: IN
      I  :: MAT5{REAL}, IN
      ID :: MAT5{REAL}, OUT
      index :: STR, IN

      ma,mb,mc,md :: INT
      a,  b, c, d :: INT
      a2,b2,c2,d2 :: REAL

      ma = ubound(ID,2)
      mb = ubound(ID,3)
      mc = ubound(ID,4)
      md = ubound(ID,5)

      ID = ZERO

      select case (index)

      case("a")
         ENSURE(ubound(I,2)>1,  "I array too small to differentiate")
         ENSURE(ubound(I,2)>ma,"I and ID arrays are incompatible")
         a2 = TWO*.a.exponent
         ID(:,1,:,:,:) = a2*I(:,2  ,1:mb,1:mc,1:md)
         do a = 2,ma
         ID(:,a,:,:,:) = a2*I(:,a+1,1:mb,1:mc,1:md) - (a-1)*I(:,a-1,1:mb,1:mc,1:md)
         end

      case("b")
         ENSURE(ubound(I,3)>1,  "I array too small to differentiate")
         ENSURE(ubound(I,3)>mb,"I and ID arrays are incompatible")
         b2 = TWO*.b.exponent
         ID(:,:,1,:,:) = b2*I(:,1:ma,2  ,1:mc,1:md)
         do b = 2,mb
         ID(:,:,b,:,:) = b2*I(:,1:ma,b+1,1:mc,1:md) - (b-1)*I(:,1:ma,b-1,1:mc,1:md)
         end

      case("c")
         ENSURE(ubound(I,4)>1,  "I array too small to differentiate")
         ENSURE(ubound(I,4)>mc,"I and ID arrays are incompatible")
         c2 = TWO*.c.exponent
         ID(:,:,:,1,:) = c2*I(:,1:ma,1:mb,2  ,1:md)
         do c = 2,mc
         ID(:,:,:,c,:) = c2*I(:,1:ma,1:mb,c+1,1:md) - (c-1)*I(:,1:ma,1:mb,c-1,1:md)
         end

      case("d")
         ENSURE(ubound(I,5)>1,  "I array too small to differentiate")
         ENSURE(ubound(I,5)>md,"I and ID arrays are incompatible")
         d2 = TWO*.d.exponent
         ID(:,:,:,:,1) = d2*I(:,1:ma,1:mb,1:mc,2  )
         do d = 2,md
         ID(:,:,:,:,d) = d2*I(:,1:ma,1:mb,1:mc,d+1) - (d-1)*I(:,1:ma,1:mb,1:mc,d-1)
         end

      end

   end

!  =================
!  Derivartive ERI's
!  =================

   make_ERI_derivatives(AA,BB,CC,DD)
   ! Make the ERI gradient integrals "AA", "BB", "CC" and "DD". The last dimension
   ! determines whether the derivative is x, y, or z.
      AA,BB,CC,DD :: MAT5{REAL}, optional, OUT

   ENSURE(present(AA) OR present(BB) OR present(CC) OR present(DD),"no output!")

      rys :: RYS*
      IIx,IIy,IIz :: MAT5{REAL}@
      AAx,AAy,AAz :: MAT5{REAL}@
      BBx,BBy,BBz :: MAT5{REAL}@
      CCx,CCy,CCz :: MAT5{REAL}@
      DDx,DDy,DDz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1

      ! One higher for differentiating
      l_e = .a.l + .b.l + 1
      l_f = .c.l + .d.l + 1 

      n_roots = (l_e+l_f+2)/2

      ! Basic 2D intermediate integrals
      IIx.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      IIy.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      IIz.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P

      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)

      ! Make one nagular unit higher for differentiating
      IIx = ZERO
      IIy = ZERO
      IIz = ZERO
      .form_2d_ints(IIx(:,:,1,:,1),IIy(:,:,1,:,1),IIz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
      .transfer_2d_ints(IIx,IIy,IIz,AB,CD,max_b=l_b,max_d=l_d) ! a & c will automatically be one unit higher

      ! Derivative A integrals
      if (present(AA)) then
      AAx.create(n_roots,l_a,l_b,l_c,l_d) 
      AAy.create(n_roots,l_a,l_b,l_c,l_d)
      AAz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"a",AAx); .differentiate(IIy,"a",AAy); .differentiate(IIz,"a",AAz)
      AA(:,:,:,:,1) = sum(AAx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      AA(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*AAy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      AA(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*AAz(:,az,bz,cz,dz),dim=1)
      AAz.destroy; AAy.destroy; AAx.destroy
      AA = fac*AA
      end

      ! Derivative B integrals
      if (present(BB)) then
      BBx.create(n_roots,l_a,l_b,l_c,l_d) 
      BBy.create(n_roots,l_a,l_b,l_c,l_d)
      BBz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"b",BBx); .differentiate(IIy,"b",BBy); .differentiate(IIz,"b",BBz)
      BB(:,:,:,:,1) = sum(BBx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      BB(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*BBy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      BB(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*BBz(:,az,bz,cz,dz),dim=1)
      BBz.destroy; BBy.destroy; BBx.destroy
      BB = fac*BB
      end

      ! Derivative C integrals
      if (present(CC)) then
      CCx.create(n_roots,l_a,l_b,l_c,l_d) 
      CCy.create(n_roots,l_a,l_b,l_c,l_d)
      CCz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"c",CCx); .differentiate(IIy,"c",CCy); .differentiate(IIz,"c",CCz)
      CC(:,:,:,:,1) = sum(CCx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      CC(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*CCy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      CC(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*CCz(:,az,bz,cz,dz),dim=1)
      CCz.destroy; CCy.destroy; CCx.destroy
      CC = fac*CC
      end

      ! Derivative D integrals
      if (present(DD)) then
      DDx.create(n_roots,l_a,l_b,l_c,l_d) 
      DDy.create(n_roots,l_a,l_b,l_c,l_d)
      DDz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"d",DDx); .differentiate(IIy,"d",DDy); .differentiate(IIz,"d",DDz)
      DD(:,:,:,:,1) = sum(DDx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      DD(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*DDy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      DD(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*DDz(:,az,bz,cz,dz),dim=1)
      DDz.destroy; DDy.destroy; DDx.destroy
      DD = fac*DD
      end

      rys.destroy
      IIz.destroy; IIy.destroy; IIx.destroy

   end

!  ===
!  Put
!  ===

   put(out)
   ! Put the object to file "out"
      self :: IN
      out :: TEXTFILE, INOUT

      out.flush
      out.text("GAUSSIAN4 output:")

      out.flush
      out.show("l_a   =",.a.l)
      out.show("l_b   =",.b.l)
      out.show("l_c   =",.c.l)
      out.show("l_d   =",.d.l)
      out.show("Ra    =",.a.position(1),.a.position(2),.a.position(3))
      out.show("Rb    =",.b.position(1),.b.position(2),.b.position(3))
      out.show("Rc    =",.c.position(1),.c.position(2),.c.position(3))
      out.show("Rd    =",.d.position(1),.d.position(2),.d.position(3))
      out.show("alpha =",.a.exponent)
      out.show("beta  =",.b.exponent)
      out.show("gamma =",.c.exponent)
      out.show("delta =",.d.exponent)

   end

end
