!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: shell.foo 4299 2014-03-18 08:48:41Z dylan_ $
!-------------------------------------------------------------------------------

module SHELL

   implicit none

   keys :: VEC{STR}@, private

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   created result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has been allocated
   end

   destroyed result (res) ::: get_from(OBJECT), pure
   ! Returns true if self has *not* been allocated
   end

!  ===========
!  Set methods
!  ===========

   set_l_chr(val) ::: PURE
   ! Read in the l symbol
      self :: INOUT
      val :: STR, IN

   ENSURE(len_trim(val)/=1,"unknown L symbol :"//trim(val))
   ENSURE(val/="L","L shells not allowed")

      l :: INT
      l_c :: STR(len=1) 

      .l_chr = val(1:1)

      .l_chr.to_lower_case

      l_c = .l_chr(1:1)

      l = 0
      select case (l_c)
         case ("s");   l = 0
         case ("p");   l = 1
         case ("d");   l = 2
         case ("f");   l = 3
         case ("g");   l = 4
         case ("h");   l = 5
         case ("i");   l = 6
         case default; l = 6 + iachar(l_c)-iachar("i")
      end

      .set_l(l)

   end

   set_l(l) :::  PURE
   ! Set the l value
      self :: INOUT
      l :: INT, IN

      .l = l

      .l_chr          = SHELL::l_chr(.l)
      .first_gaussian = GAUSSIAN_DATA:n_comp_up_to(l-1) + 1
      .last_gaussian  = GAUSSIAN_DATA:n_comp_up_to(l)

      .update

   end

   set_spherical(val) ::: pure
   ! Set sphericals to "val"
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

      .update

   end

!  ======
!  Update
!  ======

   update ::: pure
   ! Update shell basis function info
      self :: INOUT

      .n_comp = GAUSSIAN_DATA:n_comp(.l)

      .n_sph  = 2*.l + 1

      if (.is_spherical) then; .n_bf = .n_sph
      else;                    .n_bf = .n_comp
      end

   end

!  =======
!  Inquiry
!  =======

   same_as(sh) result (same) ::: pure
   ! Return TRUE if the shell "self" is the same as "sh".
      self :: IN
      sh :: SHELL, IN
      same :: BIN

      ! Check if basic arrays are created identically
      same = .l_chr==sh.l_chr &
         AND (.is_spherical          EQV sh.is_spherical) &
         AND (.exponent.created      EQV sh.exponent.created) &
         AND (.contraction.created   EQV sh.contraction.created) 

      ! If not, we are done
      if (NOT same) return

      ! Check exponents
      if (.exponent.created AND sh.exponent.created) same = .exponent.same_as(sh.exponent) 
      if (NOT same) return

      ! Check contractions ...
      if (.contraction.created   AND sh.contraction.created)   same = .contraction.same_as(sh.contraction) 

   end

   l_chr(l) result (res) ::: selfless, private, PURE
   ! Return a character representation for angular momentum "l"
      res :: STR(len=1)
      l :: INT, IN

   ENSURE(l>= 0,"angular momentum l too small:"// trim(l.to_str))
   ENSURE(l<=23,"angular momentum l too big:"// trim(l.to_str))

      select case (l)
      case (0);     res = "s"
      case (1);     res = "p"
      case (2);     res = "d"
      case (3);     res = "f"
      case (4);     res = "g"
      case default; res = achar(l-4+iachar("g"))
      end

   end

   n_prim result (res) ::: pure
   ! Return the number of primitive gaussians in the shell
      self :: IN
      res :: INT

      res = .n_bf*.n_cc

   end

   r_max(cutoff) result (res) ::: pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      alpha :: REAL

      alpha = ONE/minval(.exponent)

      if (cutoff<=ZERO) then; res = huge(ONE)
      else;                   res = sqrt(-alpha*log(cutoff/sum(abs(.contraction))))
      end

   end

   r2_max(cutoff) result (res) ::: pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      alpha :: REAL

      alpha = ONE/minval(.exponent)

      if (cutoff<=ZERO) then; res = huge(ONE)
      else;                   res = -alpha*log(cutoff/sum(abs(.contraction)))
      end

   end

!  =========================
!  Normalisation/contraction
!  =========================

   unnormalise ::: pure
   ! Assuming the existing .contraction's are initially with respect
   ! to NORMALISED primitive gaussians, take out this normalisation
   ! factor of each primitive and put it in the contraction
   ! coefficient. The normalisation factor removed is that for the
   ! cartesian component x^l.
   ! NOTE: It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components. The factor
   ! should be: 
   !   fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   ! where nx,ny,nz are the cartesian powers of the basis component
       self :: INOUT

       .contraction = .contraction &
                * (FOUR*.exponent)**(HALF*.l+HALF+QUARTER) &
                * (ONE/(.norm*sqrt(.l.double_factorial)))
   end

   renormalise ::: pure
   ! Assuming the existing contraction coefficients are with respect to raw
   ! UNNORMALISED primitive gaussians, put back this normalisation factor for
   ! each primitive gaussian, by removing this factor from from the contraction
   ! coefficients. The result will be contraction coefficients relative to
   ! normalised primitive gausian. This will undo routine "unnormalise" routine
   ! above.  The ((TWO*PI)**(THREE/FOUR)) / .norm factor is supposed to make the
   ! contraction coefficient equal to 1 for a shell with one primitive i.e. the
   ! shell is not *really* normalised. This seems to be the usual convention.
      self :: INOUT

      .contraction = .contraction / ((FOUR*.exponent)**(HALF*.l+HALF+QUARTER)) 
      .contraction = .contraction * ((TWO*PI)**(THREE/FOUR)) / .norm

   end

   norm result (res) ::: pure
   ! Return the norm of the shell, assuming that the existing contraction
   ! coefficients are with respect to NORMALISED primitive gaussians.
      self :: IN
      res :: REAL

      i,j :: INT
      sm,a,b,ab :: REAL

      sm = ZERO

      do i = 1,.n_cc

         a = .exponent(i)

         do j = 1,i-1

            b  = .exponent(j)
            ab = TWO*sqrt(a*b)/(a+b);

            sm = sm + TWO*.contraction(i)*.contraction(j)*ab**(.l+ONE+HALF);

         end

         ! This is the normalised diagonal term
         sm = sm + .contraction(i)*.contraction(i) 

      end

      res = sqrt(sm) * ((TWO*PI)**(THREE/FOUR))

   end

   make_contraction_matrix(ccm) ::: PURE
   ! Return the contraction coefficient matrix "ccm". The primitives
   ! are by default *unnormalised*.
      self :: IN
      ccm :: MAT{REAL}, OUT

   ENSURE(.n_cc>0,"no contraction coefficients")
   ENSURE(.contraction.created,"no contraction coefficients")
   ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
   ENSURE(ccm.dim2==.n_bf,"wrong 2nd dimension, ccm")

      b,p,i :: INT

      do b = 1,.n_bf       

         ! Primitive counter
         p = b               

         ! Primitive contractions
         do i = 1,.n_cc      
            ccm(p,b) = .contraction(i)
            p = p + .n_bf
         end

      end

   end

!  ==============
!  Input routines
!  ==============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the
   ! "keyword" is inputted from "stdin".
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}            "); ! exit surrounding loop
         case ("contractions="); .read_contractions
         case ("exponents=   "); .read_exponents
         case ("ex,cc=       "); .read_ex_cc
         case ("junk=        "); .read_junk
         case ("junk,ex,cc=  "); .read_junk_ex_cc
         case ("l=           "); .read_l
         case ("l_chr=       "); .read_l_chr
         case ("n_cc=        "); .read_n_cc
         case ("put          "); .put
         case ("spherical=   "); .read_spherical
         case ("units=       "); .read_units
         case default;           UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_l
   ! Read in the l symbol
      self :: INOUT

      l :: INT

      stdin.read(l)

      .set_l(l)

   end

   read_l_chr
   ! Read in the l symbol
      self :: INOUT

      word :: STR

      stdin.read(word)

      .set_l_chr(word)

   end

   read_spherical
   ! Read in if this is a spherical shell
      self :: INOUT

      stdin.read(.is_spherical)

   end

   read_n_cc
   ! Read in the number of contraction coefficients
      self :: INOUT

      stdin.read(.n_cc)

      ENSURE(.n_cc>0,"n_cc must be positive")

   end

   read_exponents ::: leaky
   ! Read in the exponents, of known length .n_cc
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.destroyed,"ex already entered")

      .exponent.create(.n_cc)

      stdin.read(.exponent)

   end

   read_contractions ::: leaky
   ! Read in the contraction coefficients, of known length .n_cc
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.contraction.destroyed,"cc already entered")

      .contraction.create(.n_cc)

      stdin.read(.contraction)

   end

   read_ex_cc ::: leaky
   ! Read in the exponents and contractions

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.destroyed,"ex already entered")
   ENSURE(.contraction.destroyed,"ex already entered")

      .exponent.create(.n_cc)
      .contraction.create(.n_cc)

      stdin.read_pair(.exponent,.contraction)

   end

   read_junk_ex_cc ::: leaky
   ! Read in the exponents and contractions preceded by a junk string

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.destroyed,"ex already entered")
   ENSURE(.contraction.destroyed,"ex already entered")

      i :: INT

      .exponent.create(.n_cc)
      .contraction.create(.n_cc)

      do i = 1,.n_cc
         stdin.skip_next_item
         stdin.read(.exponent(i))
         stdin.read(.contraction(i))
      end

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys" module variable.
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each keyword in the "keys" module variable.
   end

   set_keys(the_keys) ::: get_from(OBJECT), leaky
   ! Set the "keys" module variable.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("l",.l)
      stdout.dump("l_chr",.l_chr)
      stdout.dump("is_spherical",.is_spherical)
      stdout.dump("n_comp",.n_comp)
      stdout.dump("n_sph",.n_sph)
      stdout.dump("n_bf",.n_bf)
      stdout.dump("first_gaussian",.first_gaussian)
      stdout.dump("last_gaussian",.last_gaussian)
      stdout.dump("n_cc",.n_cc)

      stdout.dmpa("exponent",.exponent)
      stdout.dmpa("contraction",.contraction)

   end

   dump(object_name,ptr) ::: get_from(OBJECT)
   ! Dump object data as text
   end

!  ======
!  Output
!  ======

   put
   ! Put the shell information to "stdout"

      table :: VEC{TABLE_COLUMN}@

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian type shell")
      stdout.text("===================")
      stdout.flush
      stdout.show("Shell type                  =",.l_chr)
      stdout.show("L quatum no.                =",.l)
      stdout.show("is_spherical                =",.is_spherical)
      stdout.show("No. of cartesian components =",.n_comp)
      stdout.show("No. of spherical components =",.n_sph)
      stdout.show("Lexical starting index      =",.first_gaussian)
      stdout.show("Lexical end index           =",.last_gaussian)
      stdout.show("No. of contractions         =",.n_cc)
      stdout.flush

      if (.exponent.destroyed) return
      if (.contraction.destroyed) return

      ! Table headings
      table.create(2)
      table(2).set_heading("Contraction")
      table(2).set_subhead("coeff.")
      table(2).set_heading("Exponent")
      table(2).set_subhead("/au")

      ! Set table column data
      table(1).set_values(.contraction)
      table(2).set_values(.exponent)

      ! Make the table
      table.put

      ! Clean
      table.destroy

   end

end
